<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flex布局</title>
      <link href="2020/12/18/flex-bu-ju/"/>
      <url>2020/12/18/flex-bu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="Flex语法篇"><a href="#Flex语法篇" class="headerlink" title="Flex语法篇"></a>Flex语法篇</h1><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">语法篇-阮大神</a></p><ul><li>Flex（Flexible Box）：弹性布局</li></ul><h3 id="一，基本概念"><a href="#一，基本概念" class="headerlink" title="一，基本概念"></a>一，基本概念</h3><ul><li>采用Flex布局的元素，称为Flex容器（Flex container）。他的所有子元素自动成为容器成员，称为Flex项目（Flex item）</li></ul><img src="/2020/12/18/flex-bu-ju/image-20201220095004649.png" class="" title="Flex布局"><blockquote><p>容器存在默认的两根轴，水平的主轴（main axis），和垂直的交叉轴（cross axis）</p><p>项目默认按主轴排列，单个项目占据的主轴控件叫做main size，交叉轴空间叫做cross end</p></blockquote><h3 id="二，容器的属性"><a href="#二，容器的属性" class="headerlink" title="二，容器的属性"></a>二，容器的属性</h3><p>容器上有六个属性</p><blockquote><p>flex-direction</p><p>flex-wrap</p><p>flex-flow</p><p>justify-content</p><p>align-content</p></blockquote><h4 id="2-1flex-direction"><a href="#2-1flex-direction" class="headerlink" title="2.1flex-direction"></a>2.1flex-direction</h4><ul><li>决定主轴方向</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">flex-direction</span><span class="token punctuation">:</span> row/row-reverse/column/column-reverse<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*分别表示：默认水平方向，水平反方向，垂直方向，垂直反方向*/</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220100104496.png" class="" title="flex-direction"><h4 id="2-2flex-wrap"><a href="#2-2flex-wrap" class="headerlink" title="2.2flex-wrap"></a>2.2flex-wrap</h4><ul><li>默认情况下，项目都排列在一条轴线上，flex-wrap解决，如果一条轴线排列不下如何换行的问题。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap/wrap/wrap-reverse<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*默认不换行，换行，换行第一行在下方*/</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220100524250.png" class="" title="flex-wrap"><img src="/2020/12/18/flex-bu-ju/image-20201220100736377.png" class="" title="wrap-reverse"><h4 id="2-3flex-flow"><a href="#2-3flex-flow" class="headerlink" title="2.3flex-flow"></a>2.3flex-flow</h4><ul><li>flex-direction和flex-wrap的简写形式，默认值为<code>row nowrap</code></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-flow</span><span class="token punctuation">:</span> &lt;flex-direction>||&lt;flex-wrap><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-4justify-content"><a href="#2-4justify-content" class="headerlink" title="2.4justify-content"></a>2.4justify-content</h4><ul><li>定义了项目在主轴上的对齐方式</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start/flex-end/center/space-between/space-around<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*默认左对齐，右对齐，居中，两端对齐，项目两侧间隔相等*/</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220101514929.png" class="" title="justify-content"><h4 id="2-5align-items"><a href="#2-5align-items" class="headerlink" title="2.5align-items"></a>2.5align-items</h4><ul><li>根据交叉轴对齐，假设交叉轴为从上到下</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start/flex-end/center/baseline/stretch<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*交叉轴起点对齐，终点对齐，中点对齐，项目第一行文字基线对齐，默认交叉轴方向拉伸对齐*/</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220102111505.png" class="" title="align-items"><h4 id="2-6align-content"><a href="#2-6align-content" class="headerlink" title="2.6align-content"></a>2.6align-content</h4><ul><li>多根主线对齐方式（单主线不起作用）</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start/flex-end/center/space-between/space-around/stretch<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**/</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220103300007.png" class="" title="align-content"><h3 id="三，项目的属性"><a href="#三，项目的属性" class="headerlink" title="三，项目的属性"></a>三，项目的属性</h3><blockquote><p>order</p><p>flex-grow</p><p>flex-shrink</p><p>flex-basis</p><p>flex</p><p>align-self</p></blockquote><h4 id="3-1order"><a href="#3-1order" class="headerlink" title="3.1order"></a>3.1order</h4><ul><li>定义项目的排列顺序，数值越小，排列越靠前，默认为0；</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">order</span><span class="token punctuation">:</span> &lt;integer><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220103704182.png" class="" title="order"><h4 id="3-2flex-grow"><a href="#3-2flex-grow" class="headerlink" title="3.2flex-grow"></a>3.2flex-grow</h4><ul><li>定义项目的放大比例，默认为0（即，存在剩余空间也不放大。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-grow</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220104450433.png" class="" title="flex-grow"><blockquote><p>所有项目flex-grow属性都为1，等分剩余空间</p><p>类推</p></blockquote><h4 id="3-3flex-shrink"><a href="#3-3flex-shrink" class="headerlink" title="3.3flex-shrink"></a>3.3flex-shrink</h4><ul><li>定义项目的缩小比例，默认为1（即，空间如果不足，项目将缩小）</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-shrink</span><span class="token punctuation">:</span> &lt;number><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220104854968.png" class="" title="flex-shrink"><blockquote><p>如果所有项目都为1，等比例缩小</p><p>如果有一个为0，其他为1，空间不足时前者不缩小</p></blockquote><h4 id="3-4flex-basis"><a href="#3-4flex-basis" class="headerlink" title="3.4flex-basis"></a>3.4flex-basis</h4><ul><li>在分配多余空间之前，项目占据的主轴空间（main size）。浏览器也根据这个属性计算主轴是否有多余空间。默认值auto，项目本来大小。</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex-basis</span><span class="token punctuation">:</span> &lt;length>|auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>设置占据的<code>main size</code>长度，将占据固定空间</li></ul><h4 id="3-5flex"><a href="#3-5flex" class="headerlink" title="3.5flex"></a>3.5flex</h4><ul><li>flex-grow，flex-shrink，flex-basis的简写，默认值为<code>0 [1 auto]</code>.</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">flex</span><span class="token punctuation">:</span> none|auto|[ &lt;<span class="token string">'flex-grow'</span>> &lt;<span class="token string">'flex-shrink'</span>> &lt;<span class="token string">'flex-basis'</span>> ]<span class="token punctuation">}</span></code></pre><blockquote><p>快捷值：auto（1 1 auto），none（0 0 auto）</p><p>建议优先使用这个属性</p><p>后两个可选。</p></blockquote><h4 id="3-6align-self"><a href="#3-6align-self" class="headerlink" title="3.6align-self"></a>3.6align-self</h4><ul><li>允许单个项目有和其他项目不一样的对齐方式。可以覆盖<code>align-items</code> 默认值为<code>auto</code>，表示继承<code>.box </code>的<code>align-items</code></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>  <span class="token property">align-self</span><span class="token punctuation">:</span> auto/flex-start/flex-end/center/baseline/stretch<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220110456877.png" class="" title="align-self"><h1 id="Flex布局-实例篇"><a href="#Flex布局-实例篇" class="headerlink" title="Flex布局-实例篇"></a>Flex布局-实例篇</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">实例篇-阮大神</a></p><h3 id="一，骰子的布局"><a href="#一，骰子的布局" class="headerlink" title="一，骰子的布局"></a>一，骰子的布局</h3><img src="/2020/12/18/flex-bu-ju/00506193.png" class="" title="骰子">的一个面最多放置9个点，HTML模板如下：<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><blockquote><p>div元素表示 flex容器；span元素表示 flex项目</p></blockquote><h4 id="1-1单项目"><a href="#1-1单项目" class="headerlink" title="1.1单项目"></a>1.1单项目</h4><p>首先只有左上角一个点的情况，Flex布局默认左对齐。</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220111348214.png" class="" title="单项目"> <p>设置项目对齐方式，实现居中对齐和右对齐</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/*左对齐*/</span><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*右对齐*/</span><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-end<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220111740879.png" class="" title="单项目-居中"> <img src="/2020/12/18/flex-bu-ju/image-20201220111802890.png" class="" title="单项目-右对齐"><p>设置交叉轴对齐方式，可以垂直移动主轴</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/*交叉轴居中*/</span><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*交叉轴，主轴居中*/</span><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">}</span></code></pre><img src="/2020/12/18/flex-bu-ju/image-20201220112357019.png" class="" title="交叉轴居中"> <img src="/2020/12/18/flex-bu-ju/image-20201220112417035.png" class="" title="交叉轴/主轴居中"><h4 id="1-2双项目"><a href="#1-2双项目" class="headerlink" title="1.2双项目"></a>1.2双项目</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Flex布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习</title>
      <link href="2020/12/18/qian-duan-mian-shi-fu-xi/"/>
      <url>2020/12/18/qian-duan-mian-shi-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><a href="https://rainylog.com/post/ife-note-1/">https://rainylog.com/post/ife-note-1/</a></p><h3 id="1-语义化"><a href="#1-语义化" class="headerlink" title="1.语义化"></a>1.语义化</h3><ul><li><p>语义化标签，易修改易维护，无障碍阅读支持，利于SEO</p><blockquote><p>SEO:搜索引擎优化（技术：语义化H5;撰稿：使用访问者词汇，图文并茂；声望：其他站点的链接）</p></blockquote></li><li><p>结构语义化</p><blockquote><p>他们不对内容有什么本质的影响，只是页面结构规范</p><img src="/2020/12/18/qian-duan-mian-shi-fu-xi/image-20201218131903848.png" class="" title="H5语义化"></blockquote></li><li><p>头部<code>&lt;header&gt;</code> </p><blockquote><p>用法一：标注内容的标题</p><p>用法二：页面的页眉</p></blockquote></li><li><p>导航栏<code>&lt;nav&gt;</code></p><blockquote><p>两种用法</p><pre><code>&lt;!-- 案例一 --&gt;  一组只是链接的附加内容&lt;nav&gt; &lt;!-- 此处是链接 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/nav&gt;</code></pre><pre><code>&lt;!-- 案例二 --&gt;  附加内容中除了链接还有其他模块&lt;aside&gt; &lt;nav&gt;   &lt;!-- 此处是链接 --&gt; &lt;/nav&gt; &lt;section&gt;&lt;/section&gt; &lt;div&gt;&lt;/div&gt;&lt;/aside&gt;</code></pre></blockquote></li><li><p>附注<code>&lt;aside&gt;</code></p><blockquote><p>它不仅仅是侧栏，也表示周围和主要文本没有密切关系的内容，说明附加内容，解释说明，相关链接等</p><ul><li>通常为广告区域，搜索，分享链接</li><li>其中的<code>&lt;section&gt;</code>规定一个带有标题的区域（与主题内容并列显示的小块区域，独立内容（如：表单），文章分类区块）</li></ul></blockquote></li><li><p>页脚<code>&lt;footer&gt;</code></p><blockquote><p>常包含版权信息，法律限制等之类的文本或链接。</p><pre><code>// 含有其他内容时&lt;div&gt; &lt;aside&gt; &lt;!-- 其它内容 --&gt; &lt;/aside&gt; &lt;footer&gt;   &lt;!-- 法律、版权、来源、联系信息等 --&gt; &lt;/footer&gt;&lt;/div&gt;</code></pre></blockquote></li><li><p>主要内容<code>&lt;main&gt;</code></p><blockquote><p>标识主体内容，通常是<code>&lt;body&gt;</code>的子标签，可以帮助屏幕阅读工具识别页面主要部分</p></blockquote></li><li><p>文章<code>&lt;article&gt;</code></p><blockquote><p>应该包含完整的标题，文庄署名，发布时间，正文</p><ul><li>文章中包含插图时，使用新的 语义化标签<code>&lt;figure&gt;</code></li></ul><pre><code>&lt;article&gt; &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;   &lt;!-- 内容 --&gt; &lt;/p&gt; &lt;figure&gt;   &lt;img src="#" alt="插图"&gt;   &lt;figcaption&gt;这是一个插图&lt;/figcaption&gt; &lt;/figure&gt;&lt;/article&gt;</code></pre><p><code>&lt;img&gt;</code>的<code>alt</code>属性可以略去</p><p>（<code>&lt;figcaption&gt;</code>应该被放置在<code>&lt;figure&gt;</code>的第一个或最后一个）</p></blockquote></li></ul><h1 id="CSS基础面试题"><a href="#CSS基础面试题" class="headerlink" title="CSS基础面试题"></a>CSS基础面试题</h1><h3 id="1-50道CSS基础题"><a href="#1-50道CSS基础题" class="headerlink" title="1.50道CSS基础题"></a>1.50道CSS基础题</h3><p><a href="https://segmentfault.com/a/1190000013325778">https://segmentfault.com/a/1190000013325778</a></p><ol><li><p>标准css盒子模型，低版本IE盒子模型区别</p></li><li><p>box-sizing</p></li><li><p>css选择器有哪些？那些属性可以继承？优先级？</p></li><li><p>如何居中div？居中一个浮动元素？居中一个<strong>绝对定位元素</strong>？</p></li><li><p>display有哪些值？</p></li><li><p>position的值？</p></li><li><p>CSS3新特性？</p></li><li><p>Flexbox？</p></li><li><p>CSS三角？</p></li><li><p>常见兼容性问题（默认内外边距？Chrome中文文本&gt;=12px？<a href="https://cloud.tencent.com/developer/article/1444600">超链接失效？love hate</a></p></li><li><p>为什么要初始化CSS样式？</p></li><li><p>absolute的containing block计算方式？</p></li><li><p>不同浏览器下，visibility属性的collapse属性值的区别？（hidden，visible）</p></li><li><p>display：none和visibility：hidden区别？</p></li><li><p>position，display，overflow，float属性重叠会？</p></li><li><p>对BFC规范的理解（块级格式化上下文block formatting context）？<a href="https://blog.csdn.net/sinat_36422236/article/details/88763187">BFC</a></p></li><li><p>浮动？清除浮动？</p></li><li><p>上下外边距重合？</p></li><li><p>设置元素浮动后，元素的display值是？</p></li><li><p>移动端布局使用过媒体查询嘛？<a href="https://www.jianshu.com/p/2dfa5bab1ef1">媒体查询</a></p></li><li><p><a href="https://www.jianshu.com/p/da1e1ceeae1a">css预处理器</a>less，sass</p></li><li><p><a href="https://www.jianshu.com/p/4e673bf24a3b">css优化提高性能的方法？</a></p></li><li><p>浏览器是怎样解析CSS选择器的?</p></li><li><p>在网页中一个使用奇数还是偶数的字体？</p></li><li><p>margin和padding分别适合在什么场景？</p></li><li><p>元素竖向的百分比设定是相对于容器的高度嘛？</p></li><li><p><a href="https://github.com/haizlin/fe-interview/issues/182">全屏滚动</a></p></li><li><p><a href="https://www.w3cschool.cn/frontend_notebook/frontend_notebook-hl3u27a4.html">响应式设计</a></p></li><li><p><a href="https://www.cnblogs.com/coco1s/p/9453938.html">视差滚动效果</a></p></li><li><p>::before和:after中单引号和双引号的区别？<a href="https://www.php.cn/css-tutorial-412795.html">伪元素</a></p></li><li><p>对line-height理解？文本垂直居中（多行，单行）</p></li><li><p>怎么让Chrome支持小于12px字号？</p></li><li><p>让一碗面字体变清晰，变细css怎么做？（win，ios）</p></li><li><p>如果要手动写动画，最好的时间间隔是多少？60hz</p></li><li><p>li与li之间看不见的空白间隙是怎么产生的？如何解决？<code> letter-spacing: -3px;</code></p></li><li><p>有一个高度自适应的div，里面有两个div，一个高度为100px，希望另一个填满剩余高度？<code>子绝父相</code></p></li><li><p>png，jpg，gif图片格式解释？webp格式？</p></li><li><p>CSS Sprites精灵图？</p></li></ol><h3 id="2-Flex-布局"><a href="#2-Flex-布局" class="headerlink" title="2.Flex 布局"></a>2.Flex 布局</h3><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex</a></p><ul><li>传统布局基于盒子模型，<code>display属性</code>， <code>position属性</code>， <code>float属性</code></li><li>Flex布局就是弹性布局，用来为盒子模型提供最大的灵活性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火车票项目</title>
      <link href="2020/11/25/huo-che-piao-xiang-mu/"/>
      <url>2020/11/25/huo-che-piao-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="火车票项目–基于hook"><a href="#火车票项目–基于hook" class="headerlink" title="火车票项目–基于hook"></a>火车票项目–基于hook</h1><h2 id="一，项目搭建"><a href="#一，项目搭建" class="headerlink" title="一，项目搭建"></a>一，项目搭建</h2><h3 id="1-1创建项目"><a href="#1-1创建项目" class="headerlink" title="1.1创建项目"></a>1.1创建项目</h3><ul><li>使用<code>create-react-app</code>官方的脚手架工具</li></ul><pre><code>npx create-react-app train-ticket</code></pre><blockquote><p>npm:就是一个npm的命令</p><ul><li>方便调用项目内部安装的模块</li><li>避免全局安装的模块</li></ul></blockquote><h3 id="1-2编译脚本"><a href="#1-2编译脚本" class="headerlink" title="1.2编译脚本"></a>1.2编译脚本</h3><ul><li><p>在package.json文件中有</p><blockquote><p>依赖文件<code>dependencies</code></p><ul><li>除了react，react-dom外，就是react-script和一些测试的模块，可以看出主要功能都是react-script完成的。</li></ul><p>脚本文件<code>script</code></p><ol><li>start：指引到react-script中对应start.js，starts.js中后会调用webpack.config.dev.js，实现本地服务环境的搭建等</li><li>build：指引到react-script中对应build.js完成编译过程</li><li>test：测试</li><li>eject：将react-script中的代码功能下放到具体项目实践中，提高项目灵活性</li></ol></blockquote></li></ul><h3 id="1-3eject具体用法"><a href="#1-3eject具体用法" class="headerlink" title="1.3eject具体用法"></a>1.3eject具体用法</h3><pre><code>npm run eject</code></pre><ul><li>package.json中会增加很多的依赖，这个过程是不可逆的，后面多页面应用会用到修改</li></ul><h2 id="二，React新特性"><a href="#二，React新特性" class="headerlink" title="二，React新特性"></a>二，React新特性</h2><h3 id="2-1Context实现跨层级组件数据传递"><a href="#2-1Context实现跨层级组件数据传递" class="headerlink" title="2.1Context实现跨层级组件数据传递"></a>2.1Context实现跨层级组件数据传递</h3><ul><li>相当于全局变量一样，可以跨组件传递数据的组件树</li></ul><blockquote><ol><li>引入createContext函数</li></ol><ul><li>用这个函数声明想全局使用的变量</li></ul><pre><code>// 这里也可以设定属性的默认值const BatteryContext = createContext(90);const OnlineContext = createContext();</code></pre><ol start="2"><li>从provider到consumer</li></ol><ul><li>在父代的顶层state中，value属性初始化想要传递的数据</li><li>多数据使用嵌套模式</li></ul><pre><code>&lt;BatteryContext.Provider value={battery}&gt; &lt;OnlineContext.Provider value={online}&gt;   &lt;button     type="button"     onClick={() =&gt; this.setState({ battery: battery - 1 })}   &gt;   Press   &lt;/button&gt;   &lt;button     type="button"     onClick={() =&gt; this.setState({ online: !online })}   &gt;   Switch   &lt;/button&gt;   &lt;Middle /&gt;                //中间组件 &lt;/OnlineContext.Provider&gt;&lt;/BatteryContext.Provider&gt;</code></pre><pre><code>class Leaf extends Component { render() {   return (     &lt;BatteryContext.Consumer&gt;       {(battery) =&gt; (         &lt;OnlineContext.Consumer&gt;           {(online) =&gt; (             &lt;h1&gt;               Battery: {battery}, Online: {String(online)}             &lt;/h1&gt;           )}         &lt;/OnlineContext.Consumer&gt;       )}     &lt;/BatteryContext.Consumer&gt;   ); }}</code></pre><ul><li>consumer中也是嵌套使用  变量作为传入参数的箭头函数方式使用，最终返回的是JSX语法块。</li></ul></blockquote><h3 id="2-2静态属性contextType"><a href="#2-2静态属性contextType" class="headerlink" title="2.2静态属性contextType"></a>2.2静态属性contextType</h3><ul><li>这样是全局性质的值传递，影响react组件的组件化管理，所以，一般很少使用，当只是用一个数据时，我们使用一个简单方法。</li></ul><blockquote><p>类中定义contextType变量来获取对应预声明变量的值</p><p>this.context 调用这个变量</p><pre><code>static contextType = BatteryContext;// 这样就可以直接使用this.context来获取指定的数据。class Leaf extends Component { static contextType = BatteryContext; render() { const battery = this.context; return &lt;h1&gt;battery:{battery}&lt;/h1&gt;;}}</code></pre></blockquote><h3 id="2-3lazy和suspense实现延迟加载"><a href="#2-3lazy和suspense实现延迟加载" class="headerlink" title="2.3lazy和suspense实现延迟加载"></a>2.3lazy和suspense实现延迟加载</h3><ul><li>react-loadable同样实现懒加载</li></ul><blockquote><pre><code>// (1) 首先,要从react中引入 lazy 和 suspence// (2) lazy中异步导入，Suspence加载对应获取到的异步组件，回调函数就是加载过渡内容import React, { Component, lazy, Suspense } from "react";import "./App.css";const About = lazy(() =&gt; import("./about"));class App extends Component { render() {   return (     &lt;div&gt;       &lt;Suspense fallback={&lt;div&gt;loading&lt;/div&gt;}&gt;         &lt;About&gt;&lt;/About&gt;       &lt;/Suspense&gt;     &lt;/div&gt;   ); }}</code></pre></blockquote><img src="/2020/11/25/huo-che-piao-xiang-mu/lazy.png" class="" title="network"><ul><li>提高名称的辨识度，我们可以借助webpack中的注释</li></ul><p>这样2.chunk.js  就换成了更加有辨识度的about.chunk.js</p><pre><code>const About = lazy(() =&gt; import(/* webpackChunkName:"about" */ "./about"));</code></pre><h3 id="2-4错误边界"><a href="#2-4错误边界" class="headerlink" title="2.4错误边界"></a>2.4错误边界</h3><ul><li>如果上面lazy导入的文件不存在，页面就会立即报错，并且这种错误是不可以捕获的。</li><li>这样我们就要考虑react ErrorBoundary</li></ul><blockquote><p>实际上是使用了生命周期函数中的componentDidCatch方法</p><p>或者。另外一个静态方法，getDerivedStateFromError函数，一旦出现错误可以返回一个新的state数据并合并到原来的state</p><pre><code>componentDidCatch() {   this.setState({     hasError: true,   });}static getDerivedStateFromError() {   return {       hasError: true,   }}</code></pre><ul><li>效果相同开发者界面都会显示error</li></ul></blockquote><ul><li>如何在发生错误后，触发重渲染？</li></ul><blockquote><p>我们演示使用外部按钮，实现重渲染</p></blockquote><pre><code>let About = lazy(() =&gt; import(/* webpackChunkName:"about" */ "./about"));class App extends Component {  state = {    load: false,    error: false,  };  // 手动触发异步组件的加载  load = () =&gt; {    this.setState({ load: true });  };  // 加载失败后，点击重试  retry = () =&gt; {    this.setState({ error: false });  };  // ErrorBoundary 的关键，无需再实现 componentDidCatch  static getDerivedStateFromError(e) {    return { error: e };  }  render() {    const { load, error } = this.state;    // 显然错误页    if (error) {      return (        &lt;div&gt;          &lt;p&gt;{error.message}&lt;/p&gt;          &lt;button onClick={this.retry}&gt;retry&lt;/button&gt;        &lt;/div&gt;      );    }    return (      &lt;div&gt;        &lt;button type="button" onClick={this.load}&gt;          load        &lt;/button&gt;        &lt;Suspense fallback={&lt;div&gt;loading&lt;/div&gt;}&gt;{load &amp;&amp; &lt;About /&gt;}&lt;/Suspense&gt;      &lt;/div&gt;    );  }}</code></pre><blockquote><p>我们还会发现一个问题，重试没有作用，总是失败，</p><ul><li>因为，lazy中封装的promise只会执行一次，无论怎么获取它的结果，依然是失败的</li></ul></blockquote><pre><code>{  retry = () =&gt; {    About = lazy(() =&gt; import('./about.js'));    this.setState({error: false});  }}</code></pre><blockquote><p>关键在于重新渲染这个about组件</p></blockquote><h3 id="2-5Memo实现指定组件渲染"><a href="#2-5Memo实现指定组件渲染" class="headerlink" title="2.5Memo实现指定组件渲染"></a>2.5Memo实现指定组件渲染</h3><ul><li>react有一个特点，组件渲染，render中包含的其他组件也会无条件渲染，即使没有数据变化。</li><li>react给我吗提供了一个生命周期函数<code>shouldComponentUpdate(nextProps, nextState) {}</code> 通过比较<code>this.props和nextProps；this.state和nextState</code>数据是否变化，返回true/false，来决定组件是否更新</li><li>当然react给我们提供了更加方便的使用方法。</li></ul><blockquote><p>对于class组件来说：pureComponent</p><ul><li>只做浅比较，对句柄来比较，复杂数据类型，没有多级比较</li></ul><p>对于无状态组件来说：memo</p><ul><li>用memo()来包裹生成新的组件</li></ul></blockquote><pre><code>const Foo = memo(function Foo(props) {  console.log("Foo render");  return &lt;div&gt;{props.person.age}&lt;/div&gt;;});</code></pre><ul><li>对于复杂数据类型，无状态组件，可以通过对memo传入第二个函数参数<code>areEqual</code></li></ul><pre><code>const Foo = memo(function Foo(props) {  console.log("Foo render" + props.person.age);  return &lt;div&gt;{props.person.age}&lt;/div&gt;;}, areEqual);function areEqual(prevProps, nextProps) {  return prevProps.person.age === nextProps.person.age;}</code></pre><p><strong>一定要用setState来改变数据</strong></p><h2 id="三，React-Hooks"><a href="#三，React-Hooks" class="headerlink" title="三，React Hooks"></a>三，React Hooks</h2><p><strong>类组件的不足</strong></p><ul><li><p>状态逻辑难复用</p><ul><li>缺少复用机制</li><li>渲染属性和告诫组件导致层级冗余</li></ul><pre><code>1. “render prop”  React组件之间使用一个值为函数的prop共享//想要实现鼠标移动后面跟着cat， &lt;Cat&gt;组件使用&lt;mouse&gt;组件的数据 //render方法中的函数传给有数据的&lt;mouse&gt;，告诉他需要渲染声明内容。让mouse组件变得有复用性//要注意mouse组件不能和PureComponent一起用，因为每次传入的prop肯定不一样，PureComponent没有意义    要让prop为静态，可以利用浅比较传入一个定义了的实例方法class Cat extends React.Component {  render() {    const mouse = this.props.mouse;    return (      &lt;img src="/cat.jpg" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /&gt;    );  }}class Mouse extends React.Component {  constructor(props) {    super(props);    this.handleMouseMove = this.handleMouseMove.bind(this);    this.state = { x: 0, y: 0 };  }  handleMouseMove(event) {    this.setState({      x: event.clientX,      y: event.clientY    });  }  render() {    return (      &lt;div style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}&gt;        {/*          使用 `render`prop 动态决定要渲染的内容，          而不是给出一个 &lt;Mouse&gt; 渲染结果的静态表示        */}        {this.props.render(this.state)}      &lt;/div&gt;    );  }}class MouseTracker extends React.Component {  render() {    return (      &lt;div&gt;        &lt;h1&gt;移动鼠标!&lt;/h1&gt;        &lt;Mouse render={mouse =&gt; (          &lt;Cat mouse={mouse} /&gt;        )}/&gt;      &lt;/div&gt;    );  }}2. HOC高阶组件  参数为组件，返回值为新组件的函数// 例如Redux中的 connectconst WrapperedFoo = resizable(Foo);&lt;WrapperedFoo/&gt;;</code></pre></li><li><p>类组件难以维护</p><ul><li>生命周期函数混杂不相干逻辑</li><li>相干逻辑分散在不同生命周期</li></ul></li><li><p>this指向困扰</p></li></ul><p><strong>Hooks优势</strong></p><ul><li>函数组件不存在this问题</li><li>方便复用状态逻辑</li><li>副作用关注点分离</li></ul><blockquote><p>副作用：数据获取，设置订阅或者手动直接更改 React 组件中的 DOM 都属于副作用。</p><p>副作用的时机：Mount之后，Update之后，Unmount之前</p></blockquote><h3 id="3-1useState使用"><a href="#3-1useState使用" class="headerlink" title="3.1useState使用"></a>3.1useState使用</h3><ul><li>设置修改组件的state，Hooks提供了新的手段<code>useState</code></li></ul><pre><code>// 引入useState  参数为默认值function App() {    const [count, setCount] = useState(0);  return (      &lt;button      type="button"      onClick={()=&gt;{setCount(count + 1)}}    &gt;    Click ({count})    &lt;/button&gt;  );}export default App;</code></pre><ul><li>注意问题</li></ul><blockquote><ul><li>使用useState时，时借助了js的单线程特性，判断当前的useState调用当前的变量而不会混乱。</li><li>当有多个变量时，必须<strong>顺序调用</strong>，<strong>调用数量匹配</strong>否则会出现错误</li></ul></blockquote><p>新版都自动集成了eslint-plugin-react-hooks  更加友好的错误信息</p><ul><li>转换逻辑时 利用默认值函数只调用一次提升性能</li></ul><pre><code>function App(props) {    const [count, setCount] = useState(() =&gt; {        return props.defaultCount || 0;    })}</code></pre><ul><li>setCount函数句柄是稳定的！！</li></ul><h3 id="3-2Effect-Hooks"><a href="#3-2Effect-Hooks" class="headerlink" title="3.2Effect Hooks"></a>3.2Effect Hooks</h3><ul><li><p>处理副作用的时机之前都是三个生命周期函数处理的</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul></li><li><p>现在我们使用useEffect完成相应操作</p></li></ul><pre><code>function App(props) {  const [count, setCount] = useState(0);  const [size, setSize] = useState({    width: document.documentElement.clientWidth,    height: document.documentElement.clientHeight,  });  const onResize = () =&gt; {    setSize({      width: document.documentElement.clientWidth,      height: document.documentElement.clientHeight,    });  };  useEffect(() =&gt; {    console.log("count:", count);  }, [count]);  useEffect(() =&gt; {    document.title = count;  });  useEffect(() =&gt; {    window.addEventListener("resize", onResize, false);    return () =&gt; {      window.removeEventListener("resize", onResize, false);    };  }, []);    const onClick = () =&gt; {    console.log("click");  };  useEffect(() =&gt; {    document.querySelector("#size").addEventListener("click", onClick, false);    return () =&gt; {      document        .querySelector("#size")        .removeEventListener("click", onClick, false);    };  });  return (    &lt;div&gt;      &lt;button        type="button"        onClick={() =&gt; {          setCount(count + 1);        }}      &gt;        Click ({count})      &lt;/button&gt;      {count % 2 ? (        &lt;span id="size"&gt;          size: {size.width}x{size.height}        &lt;/span&gt;      ) : (        &lt;p id="size"&gt;          size: {size.width}x{size.height}        &lt;/p&gt;      )}    &lt;/div&gt;  );}</code></pre><blockquote><ul><li>useEffect有两个参数</li></ul><ol><li>前一个参数：处理副作用函数</li><li>后一个参数（可选）：变化数组（多次执行），常量数组（只执行一次）。</li></ol><ul><li>多个副作用功能分开多个useEffect管理更加方便</li><li>remove操作，当事件移除时才会解绑</li><li>当组件return jsx之后才执行useEffect</li></ul></blockquote><p><strong>注意</strong></p><blockquote><ul><li>异步处理函数中的数据都是前一次的句柄</li><li>很奇怪的是：onResize事件中回调函数中永远保存着原始大小的句柄。（向下还原算两次事件触发，最大化算一次时间触发）</li><li>函数作用域内的数据都是同步的最新数据</li></ul></blockquote><p><strong>类属性</strong>声明state和constructor中声明没什么区别</p><h3 id="3-3Context-Hooks"><a href="#3-3Context-Hooks" class="headerlink" title="3.3Context Hooks"></a>3.3Context Hooks</h3><ul><li><strong>类组件</strong>中可以使用<code>Count.Provider</code> <code>Count.Consumer</code>来对一到多个变量的调用；使用<code>static contextType = CountContext</code>对一个变量进行传递</li><li><strong>函数组件</strong> 就是要使用到这里的<code>useContext()</code>而且没有个数限制。</li></ul><pre><code>import React, { Component, useState, createContext, useContext } from "react";const CountContext = createContext();class Foo extends Component {  render() {    return (      &lt;CountContext.Consumer&gt;        {(count) =&gt; &lt;h1&gt;{count}&lt;/h1&gt;}      &lt;/CountContext.Consumer&gt;    );  }}class Bar extends Component {  static contextType = CountContext;  render() {    const count = this.context;    return &lt;h1&gt;{count}&lt;/h1&gt;;  }}function Counter() {  const count = useContext(CountContext);  return &lt;h1&gt;{count}&lt;/h1&gt;;}function App(props) {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;button        type="button"        onClick={() =&gt; {          setCount(count + 1);        }}      &gt;        Click ({count})      &lt;/button&gt;      &lt;CountContext.Provider value={count}&gt;        &lt;Foo /&gt;        &lt;Bar /&gt;        &lt;Counter /&gt;      &lt;/CountContext.Provider&gt;    &lt;/div&gt;  );}</code></pre><h3 id="3-4useMemo和callBack"><a href="#3-4useMemo和callBack" class="headerlink" title="3.4useMemo和callBack"></a>3.4useMemo和callBack</h3><ul><li><p>函数组件中定义<strong>一段函数是否执行</strong>，memo是对组件而言</p></li><li><p>不像useEffect在下一次渲染的时候触发，useMemo是渲染过程中执行，参与本次渲染数据变化。</p></li></ul><pre><code>useMemo(()=&gt;{},[])  //前：要处理的函数段返回值，后：依赖项//对内置函数包装时使用useCallbackuseCallback(()=&gt;{},[])  //返回一个函数体</code></pre><pre><code>import React, { useMemo, useState, memo, useCallback } from "react";const Counter = memo(function Counter(props) {  console.log("Counter render");  const { count } = props;  props.onClick();  return &lt;h1&gt;{count}&lt;/h1&gt;;});function App(props) {  const [count, setCount] = useState(0);  const double = useMemo(() =&gt; {    return count * 2;  }, [count === 4]);  const onClick = useCallback(() =&gt; {    console.log("click" + clickCount);  }, []);  //让onClick句柄不变化，只会返回一次！！！  return (    &lt;div&gt;      &lt;button        type="button"        onClick={() =&gt; {          setCount(count + 1);        }}      &gt;        Click ({count}), double: ({double})      &lt;/button&gt;      &lt;Counter count={double} onClick={onClick} /&gt;    &lt;/div&gt;  );}</code></pre><ul><li>我们不能阻止useCallback生成新的函数消耗性能，但是可以控制不让他返回（依赖项）</li><li>作用在于，优化因传入组件的值的过度变化而导致组件过度渲染</li></ul><h3 id="4-5-Ref-Hooks"><a href="#4-5-Ref-Hooks" class="headerlink" title="4.5 Ref Hooks"></a>4.5 Ref Hooks</h3><ul><li>具有实例化对象的class组件中，可以使用createRef()来连接操作DOM。</li><li>函数组件中没有实例化对象所以，使用新的API <code>useRef()</code></li></ul><ol><li>获取DOM</li></ol><blockquote><ul><li><p>获取函数组件时，要把函数组件转换为class组件才能被ref获取。</p></li><li><p>常见用法是调用获取组件中的方法</p></li></ul><pre><code>//想要获取Counter组件中的speak()方法class Counter extends PureComponent { speak() {   console.log(`now counter is: ${this.props.count}`); } render() {   const { props } = this;   return &lt;h1 onClick={props.onClick}&gt;{props.count}&lt;/h1&gt;; }}&lt;Counter ref={counterRef} count={double} onClick={onClick} /&gt;//对应组件中声明，调用const counterRef = useRef();const onClick = useCallback(() =&gt; {   console.log("click");   setCountadd((countadd) =&gt; countadd + 1);   counterRef.current.speak();}, []);</code></pre></blockquote><ol start="2"><li>渲染周期之间共享数据</li></ol><blockquote><ul><li>因为每次渲染组件后，组件中的变量都会变化</li><li>要想在渲染周期之间共享数据（state/useRef）</li><li>但是state操作会触发渲染，会很麻烦</li></ul><pre><code>//声明  每次周期渲染it都是共享不变的const it = useRef();//调用useEffect(() =&gt; { it.current = setInterval(() =&gt; {     setCount((count) =&gt; count + 1); }, 1000);}, []);useEffect(() =&gt; { if (count &gt; 10) {        clearInterval(it.current); }});</code></pre></blockquote><h3 id="4-6自定义Hooks"><a href="#4-6自定义Hooks" class="headerlink" title="4.6自定义Hooks"></a>4.6自定义Hooks</h3><ul><li>以<code>use---</code> 作为组件名的React函数组件，和普通函数组件的区别就是输入输出参数不一样。</li><li>自定义Hooks函数多用在封装功能，方便复用，内部可以使用Hooks所有钩子函数。</li></ul><pre><code>// 举例：想要封装复用查询好友在线状态的功能function useFriendStatus(friendID) {  const [isOnline, setIsOnline] = useState(null);  // ...  return isOnline;}</code></pre><pre><code>//使用订阅好友状态的自定义hook函数// (1)显示好友状态function FriendStatus(props) {  const isOnline = useFriendStatus(props.friend.id);  if (isOnline === null) {    return 'Loading...';  }  return isOnline ? 'Online' : 'Offline';}// (2)生成好友状态列表function FriendListItem(props) {  const isOnline = useFriendStatus(props.friend.id);  return (    &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;      {props.friend.name}    &lt;/li&gt;  );}</code></pre><h3 id="4-7使用Hook的注意点"><a href="#4-7使用Hook的注意点" class="headerlink" title="4.7使用Hook的注意点"></a>4.7使用Hook的注意点</h3><ol><li><h5 id="只在最顶层使用-Hook"><a href="#只在最顶层使用-Hook" class="headerlink" title="只在最顶层使用 Hook"></a>只在最顶层使用 Hook</h5><ul><li>不要在循环或嵌套函数中使用Hook</li><li>确保 Hook 在每一次渲染中都按照同样的顺序被调用</li></ul></li><li><p>生命周期方法对应到Hook</p><ul><li><p>constructer</p><p>函数组件不需要构造函数，使用<code>useState()</code>初始化state,初始值复杂表达式时可以传入一个箭头函数return这个表达式（这个函数只会在首次组件搭载时运行，优化性能）</p></li><li><p>shouldComponentUpdate()</p><p>也就是<code>useMemo()</code> <code>useCallback()</code></p></li><li><p>render</p><p>就是函数组件本身</p></li><li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code></p><p>useEffect()副作用函数</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_React </tag>
            
            <tag> hook </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS_Module</title>
      <link href="2020/11/10/css-module/"/>
      <url>2020/11/10/css-module/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h1><ul><li>react编写过程中我们会发现，css文件都是全局作用的，这样就会产生样式混叠名称难以设置的问题</li><li>CSS Module帮我们解决了这一问题，</li></ul><h2 id="1-局部作用域"><a href="#1-局部作用域" class="headerlink" title="1.局部作用域"></a>1.局部作用域</h2><ul><li>产生局部作用域的唯一方法就是，使用一个独一无二的<code>className</code>，这也就是CSS Module的做法。</li></ul><blockquote><p>这里我们先使用<code>create-react-app</code> 这个官方脚手架（2.0以后完全兼容了css module）</p></blockquote><pre><code> [name].module.css                                        //命名规范 import xxx from 'xxx.module.css'            //引用方法 &lt;div className={xxx.styleName}&gt;            //用法</code></pre><ul><li><h5 id="Button-module-css"><a href="#Button-module-css" class="headerlink" title="Button.module.css"></a><code>Button.module.css</code></h5></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.error</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><h5 id="Button-js"><a href="#Button-js" class="headerlink" title="Button.js"></a><code>Button.js</code></h5></li></ul><pre><code>import React, { Component } from 'react';import styles from './Button.module.css'; // Import css modulesclass Button extends Component {  render() {    return &lt;button className={styles.error}&gt;Error Button&lt;/button&gt;;  }}</code></pre><ul><li><h5 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h5></li></ul><pre><code>//[filename]\_[classname]\_\_[hash]&lt;button class="Button_error_ax7yz"&gt;Error Button&lt;/button&gt;</code></pre><h2 id="2-全局作用域"><a href="#2-全局作用域" class="headerlink" title="2.全局作用域"></a>2.全局作用域</h2><ul><li>CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局规则。凡是这样声明的<code>class</code>，<u>都不会被编译成哈希字符串</u>。</li></ul><pre><code> xxx.css                                                   //命名规范 import ‘xxx.css’                                    //引用方法 &lt;div className='styleName'&gt;            //用法</code></pre><ul><li><h5 id="App-css"><a href="#App-css" class="headerlink" title="App.css"></a><code>App.css</code></h5></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token pseudo-class">:global(.title)</span> </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><h5 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a><code>App.js</code></h5></li></ul><pre><code>import React, { Component } from 'react';import from './App.css'; // Import css modulesclass App extends Component {  render() {    return (      &lt;h1 className="title"&gt;        Hello World      &lt;/h1&gt;    );  }}</code></pre><ul><li><h5 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h5></li></ul><pre><code>//不进行哈希编码&lt;h1 data-reactroot="" class="title"&gt;Hello World&lt;/h1&gt;</code></pre><h4 id="补充点"><a href="#补充点" class="headerlink" title="补充点"></a>补充点</h4><ul><li>CSS Modules 还提供一种显式的局部作用域语法<code>:local(.className)</code>，等同于<code>.className</code></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector">//等效写法<span class="token pseudo-class">:local(.title)</span> </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token pseudo-class">:global(.title)</span> </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3-定制哈希类名"><a href="#3-定制哈希类名" class="headerlink" title="3.定制哈希类名"></a>3.定制哈希类名</h2><pre><code>create-react-app:默认的哈希算法是 [path][name]__[local]--[hash:base64:5]</code></pre><ul><li>webpack中<code>css-loader</code>默认的哈希算法是<code>[hash:base64]</code>，这会将<code>.title</code>编译成<code>._3zyde4l1yATCOkgn-DBWEL</code>这样的字符串。</li><li><code>webpack.config.js</code> 里面可以定制哈希字符串的格式。</li></ul><h2 id="4-Class组合"><a href="#4-Class组合" class="headerlink" title="4.Class组合"></a>4.Class组合</h2><ul><li><p>一个选择器可以继承另一个选择器的规则，这称为”组合”</p></li><li><h4 id="composes"><a href="#composes" class="headerlink" title="composes"></a>composes</h4></li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.className</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.title</span> </span><span class="token punctuation">{</span>  <span class="token property">composes</span><span class="token punctuation">:</span> className<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span>//蓝底红字</code></pre><pre><code>//被编译成._2DHwuiHWMnKTOYG45T0x34 {  color: red;}._10B-buq6_BEOTOl9urIjf8 {  background-color: blue;}&lt;h1 class="_2DHwuiHWMnKTOYG45T0x34 _10B-buq6_BEOTOl9urIjf8"&gt;</code></pre><h2 id="5-输入其他模块"><a href="#5-输入其他模块" class="headerlink" title="5.输入其他模块"></a>5.输入其他模块</h2><ul><li>选择器也可以继承其他CSS文件中的规则</li></ul><p><strong>another.css</strong></p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.className</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>App.css</strong>可以继承<code>another.css</code>里面的规则</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.title</span> </span><span class="token punctuation">{</span>  <span class="token property">composes</span><span class="token punctuation">:</span> className from <span class="token string">'./another.css'</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>未完待续。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简书项目</title>
      <link href="2020/11/08/jian-shu-xiang-mu/"/>
      <url>2020/11/08/jian-shu-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="简书项目"><a href="#简书项目" class="headerlink" title="简书项目"></a>简书项目</h1><h2 id="Header组件开发"><a href="#Header组件开发" class="headerlink" title="Header组件开发"></a>Header组件开发</h2><h3 id="样式问题Styled-Components"><a href="#样式问题Styled-Components" class="headerlink" title="样式问题Styled-Components"></a>样式问题Styled-Components</h3><ul><li>react项目文件中的css文件都是一个引用全局受用，这样就会造成样式混乱管理的问题</li></ul><p><strong>我们引入Styled-Components结合Reset.css</strong></p><pre><code>// (1)安装Styled-Componentsnpm install Styled-Components// (2)项目目录下创建一个style.js文件来存放样式// 引入对应全局样式的 apiimport { createGlobalStyle } from "styled-components";// (3)创建一个组件，以组件的形式导出对应样式const GlobalStyle = createGlobalStyle`  ...Reset.css //统一规范样式`;export default GlobalStyle;// (4)以组件的形式使用添加到对应JSX语法块中&lt;Fragment&gt;  &lt;div className="body"&gt;minyue&lt;/div&gt;  &lt;GlobalStyle /&gt;&lt;/Fragment&gt;</code></pre><h3 id="完成header组件布局"><a href="#完成header组件布局" class="headerlink" title="完成header组件布局"></a>完成header组件布局</h3><ol><li>在src目录下新建<code>common文件夹</code>来装公共样式</li><li>common文件夹下再新建<code>header文件夹</code>，新建<code>index.js文件</code>，样式文件<code>style.js</code>来设置头部样式</li></ol><blockquote><p>这里我们使用styled-components布局方式—-组件化布局方式</p><pre><code>&lt;HeaderWrapper&gt; &lt;Logo&gt;&lt;/Logo&gt; &lt;Nav&gt;   &lt;NavItem className="left"&gt;首页&lt;/NavItem&gt;   &lt;NavItem className="left"&gt;下载APP&lt;/NavItem&gt;   &lt;NavSearch&gt;&lt;/NavSearch&gt;   &lt;NavItem className="right"&gt;登录&lt;/NavItem&gt;   &lt;NavItem className="right"&gt;Aa&lt;/NavItem&gt; &lt;/Nav&gt;&lt;/HeaderWrapper&gt;</code></pre><ul><li>样式作为一个个块的组件搭建起来，在样式文件样式文件中完成标签类型的设定，组件形式导出</li></ul><pre><code>// (1)引入包文件import styled from "styled-components";import logoPic from "../../statics/logo.png";// (2)组件形式编写样式组件export const Logo = styled.a.attrs({ href: "/",})` position: absolute; top: 0; left: 0; display: block; width: 100px; height: 56px; background: url(${logoPic}); background-size: contain;`;export const NavItem = styled.div` line-height: 56px; padding: 0 15px; font-size: 17px; color: #333; &amp;.left {   float: left; } &amp;.right {   float: right; } &amp;.active {   color: #ea6f5a; }`;export const NavSearch = styled.input.attrs({ placeholder: "search",})` width: 160px; height: 38px; padding: 0 20px; margin-top: 9px; margin-left: 20px; box-sizing: border-box; border: none; outline: none; border-radius: 19px; background: #eee; font-size: 14px; &amp;::placeholder {   color: #999; }`;</code></pre><p><strong>注意事项</strong></p><ol><li>图片的插入方式！！！</li><li>设置标签的其他默认属性，及其样式的方法（href，placeholder等）</li><li>如何使用选择器（<code>&amp;.className{}</code>）</li></ol></blockquote><h3 id="字体图标的使用"><a href="#字体图标的使用" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h3><ul><li><p>和图片一样作为静态数据，我们存放在<code>statics</code> 中</p></li><li><p><code>iconfont</code> 下删掉没有用的文件，将<code>iconfont.css</code> 改为<code> iconfont.js</code>,把字体图标的样式当做一个全局组件使用<code>createGlobalStyle</code> 函数。</p></li></ul><p><strong>App.js</strong></p><pre><code>import React, { Fragment } from "react";import { GlobalStyle } from "./style";import { GlobalIconFont } from "./statics/iconfont/iconfont";import Header from "./common/header/index.js";function App() {  return (    &lt;Fragment&gt;      &lt;Header /&gt;      &lt;GlobalStyle /&gt;      &lt;GlobalIconFont /&gt;    &lt;/Fragment&gt;  );}export default App;</code></pre><p><strong>iconfont.js</strong></p><pre><code>import { createGlobalStyle } from "styled-components";export const GlobalIconFont = createGlobalStyle`    ....`;</code></pre><p><strong>style.js</strong></p><pre><code>import { createGlobalStyle } from "styled-components";// 不同浏览器的统一样式规范export const GlobalStyle = createGlobalStyle`    .....`;</code></pre><p><strong>header/style.js</strong></p><table><thead><tr><th>样式问题</th><th></th></tr></thead><tbody><tr><td>.className</td><td>下一级含有该类，下一级元素的样式设定</td></tr><tr><td>&amp;.className</td><td>&amp;（表示当前元素），同级元素含有对应类的元素进行样式设定</td></tr><tr><td>.attrs({ 默认属性 }）</td><td>对当前元素默认属性的设置</td></tr><tr><td>&amp;::placeholder {}</td><td>对当前元素的伪类元素进行样式设定（默认内容属性，类似元素的伪类属性）</td></tr></tbody></table><h3 id="搜索框的动态效果"><a href="#搜索框的动态效果" class="headerlink" title="搜索框的动态效果"></a>搜索框的动态效果</h3><blockquote><p>使用 react-redux实现</p></blockquote><ul><li>这里就需要一个状态，和两个action</li></ul><ol><li>安装react-transition-group</li></ol><pre><code>npm install react-transition-group --save</code></pre><ol start="2"><li>写搜索框样式</li></ol><pre><code>&lt;SearchWrapper&gt;  &lt;CSSTransition    in={props.focused}    timeout={200}    classNames="slide"   &gt;    &lt;NavSearch      className={props.focused ? 'focused': ''}      onFocus={props.handleInputFocus}      onBlur={props.handleInputBlur}    &gt;&lt;/NavSearch&gt;  &lt;/CSSTransition&gt;  &lt;i className={props.focused ? 'focused iconfont': 'iconfont'}&gt;    &amp;#xe614;  &lt;/i&gt;&lt;/SearchWrapper&gt;//对应搜索框下    &amp;.focused {    width: 240px;  }    &amp;.slide-enter {    width: 160px;  }  &amp;.slide-enter-active {    transition: all 0.2s ease-out;    width: 240px;  }  &amp;.slide-exit {    width: 240px;  }  &amp;.slide-exit-active {    width: 160px;    transition: all 0.2s ease-out;  }</code></pre><h3 id="使用react-redux管理数据"><a href="#使用react-redux管理数据" class="headerlink" title="使用react-redux管理数据"></a><strong>使用react-redux管理数据</strong></h3><ol><li>先安装redux，react-redux</li></ol><pre><code>npm install redux;npm install react-redux;</code></pre><ol start="2"><li>App.js中引入Privider，连接store</li></ol><pre><code>import store from "./store";import { Provider } from "react-redux";//使用&lt;Provider store={store}&gt;  &lt;Header /&gt;  &lt;GlobalStyle /&gt;  &lt;GlobalIconFont /&gt;&lt;/Provider&gt;</code></pre><ol start="3"><li>header/index.js中连接store </li></ol><pre><code>import { connect } from "react-redux";//使用const mapStateToProps = (state) =&gt; {  return {    focused: state.focused,  };};const mapDispathToProps = (dispatch) =&gt; {  return {    handleInputFocus() {      const action = {        type: "search_focus",      };      dispatch(action);    },    handleInputBlur() {      const action = {        type: "search_blur",      };      dispatch(action);    },  };};export default connect(mapStateToProps, mapDispathToProps)(Header);</code></pre><ul><li>注意将文章中的state用props替换</li></ul><ol start="4"><li>src下创建store编写index.js/reducer.js</li></ol><pre><code>(1)reducer是一个纯函数,返回一个对象(2)index.js中使用createStore，compose  API（参考react-devtools使用方法）</code></pre><h3 id="composeEnhancers数据拆分管理"><a href="#composeEnhancers数据拆分管理" class="headerlink" title="composeEnhancers数据拆分管理"></a>composeEnhancers数据拆分管理</h3><ul><li>把src下的store/reducer.js下放到对应区块的子store中，更加方便管理数据</li></ul><ol><li>在header下新建store</li></ol><pre><code>//reducer移入之前的内容....//导出路径过长，新建一个index.js导出对应reducer，就会是调用路径减少两层import reducer from './reducer';export { reducer };</code></pre><ol start="2"><li>src下的总reducer，汇总功能</li></ol><pre><code>//引入combineReducers()//es6语法 ’as‘ 名称替代写法(名称重复时使用)import { combineReducers } from 'redux';import { reducer as headerReducer } from '../common/header/store';const reducer = combineReducers({    header: headerReducer});export default reducer;</code></pre><ul><li>注意<code>focused: state.header.focused,</code>  要加中间header</li></ul><h3 id="immutable-js管理数据"><a href="#immutable-js管理数据" class="headerlink" title="immutable.js管理数据"></a>immutable.js管理数据</h3><ul><li>为了确保reducer中不会返回一个<strong>”有问题“的”state“</strong>，我们设法把defaultState设定成有权限的数据类型</li></ul><p><strong>引入<code>immutable.js</code> 的 fromJS()</strong></p><ol><li>安装</li></ol><pre><code>//分支reducer需要 fromJS函数npm install immutable//总reducer需要 新的合并函数npm install redux-immutable</code></pre><ol start="2"><li>header/store/reducer.js</li></ol><pre><code>// 把state模板设置为immutable对象import { fromJS } from "immutable";const defaultState = fromJS({  focused: false,});</code></pre><ul><li>返回对象时要用对应immutable对象提供的</li></ul><pre><code>return state.set("focused", true);</code></pre><ol start="3"><li>总reducer</li></ol><pre><code>//相当于combineRducers函数升级了import { combineReducers } from "redux-immutable";</code></pre><ol start="4"><li>更改数据引用方式</li></ol><blockquote><p>我们使用了immutable后，store下面数据的引用不再使用’.属性‘来实现        需要通过immutable提供的API</p></blockquote><pre><code>// props和state连接时// focused: state.get("header").get("focused"),focused: state.getIn(["header", "focused"]),</code></pre><h3 id="Ajax获取热门搜索框数据"><a href="#Ajax获取热门搜索框数据" class="headerlink" title="Ajax获取热门搜索框数据"></a>Ajax获取热门搜索框数据</h3><ol><li>异步获取数据，引入中间件redux-thunk</li></ol><pre><code>npm install redux-thunk</code></pre><ul><li>修改store/index.js</li></ul><pre><code>//引入applyMiddleware//引入thunkimport { createStore, compose, applyMiddleware } from "redux";import thunk from "redux-thunk";//在composeEnhancers中添加中间件const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk)));</code></pre><ol start="2"><li>热门搜索框效果添加</li></ol><ul><li>index.js中</li></ul><pre><code>// (1) 把搜索框写入一个函数组件，当focus（true）时返回样式，并添加到searchWrapper中getListArea() {    const { focused, list } = this.props;    if (focused) {      return (        &lt;SearchInfo&gt;          &lt;SearchInfoTitle&gt;            热门搜索            &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt;          &lt;/SearchInfoTitle&gt;          &lt;SearchInfoList&gt;            {list.map((item) =&gt; {              return &lt;SearchInfoItem key={item}&gt;{item}&lt;/SearchInfoItem&gt;;            })}          &lt;/SearchInfoList&gt;        &lt;/SearchInfo&gt;      );    } else {      return null;    }}// (2)style.js样式！！！// (3)数据需要一个listlist: state.getIn(["header", "list"]),dispatch(actionCreators.getList());</code></pre><ol start="3"><li>数据的异步获取</li></ol><ul><li>actionCreaters.js</li></ul><pre><code>// 异步获取数据请求// (1)安装axios模块npm install axios//getList 可以返回一个函数了！！//模拟数据可以放在public/api下(程序会检索到这里)export const getList = () =&gt; {  return (dispatch) =&gt; {    axios      .get("/api/headerList.json")      .then((res) =&gt; {        const data = res.data;        dispatch(changeList(data.data));      })      .catch(() =&gt; {        console.log("error");      });  };};const changeList = (data) =&gt; ({  type: actionTypes.CHANGE_LIST,  data: fromJS(data),  //data类型匹配！！});</code></pre><ul><li>reducer.js</li></ul><pre><code>// (1)defaultState 中添加list项  注意他是一个immutable类型// (2)处理程序添加一项case actionTypes.CHANGE_LIST:  return state.set("list", action.data); //data也应该是immutable类型</code></pre><ul><li>注意这里Ajax请求<strong>只需要请求一次</strong></li></ul><blockquote><p>但是只要我们点击输入框就会触发Ajax请求，我们需要修改，当list为空时才发起请求！！</p><pre><code>// 将list传入函数 handleInputFocushandleInputFocus(list) {   list.size === 0 &amp;&amp; dispatch(actionCreators.getList());   dispatch(actionCreators.searchFocus());},</code></pre><ul><li>immutable对象没有length只有size判断list的长度</li></ul></blockquote><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h4><table><thead><tr><th align="left">1.添加结构(发现要什么数据，什么行为)</th><th>index.js</th></tr></thead><tbody><tr><td align="left"><strong>2.connect的两函数实现数据连接，行为传递</strong></td><td><strong>index.js</strong></td></tr><tr><td align="left"><strong>3.actionCreaters对行为做集中处理，返回action，调用dispatch传递行为(异步行为，返回一个函数，函数中会再次调用actionCreaters中的函数返回行为对象，并在返回的函数中实现dispatch)</strong></td><td><strong>actionCreaters.js</strong></td></tr><tr><td align="left"><strong>4.reducer中添加默认数据种类，添加处理程序（使用immutable时，注意数据类型的匹配）</strong></td><td><strong>reducer.js</strong></td></tr><tr><td align="left"><strong>5.检查完善(结构化赋值，等),数据文件的编写</strong></td><td><strong>actionTypes.js(public/api/..)</strong></td></tr></tbody></table><h4 id="bug解决"><a href="#bug解决" class="headerlink" title="bug解决"></a>bug解决</h4><ul><li>我们可以看到，点击热门搜索框内内容搜索框失焦，热门搜索框也跟着关闭了？？</li></ul><p><strong>index.js</strong></p><pre><code>// (1)给热门搜索框增加一个mouseIn判断值if (focused || mouseIn) {    return (        &lt;SearchInfo             onMouseEnter={handleMouseEnter}            onMouseLeave={handleMouseLeave}        &gt;        ...    )}        //添加一个mouseIn的数据，走一遍流程</code></pre><h3 id="热门搜索换页功能"><a href="#热门搜索换页功能" class="headerlink" title="热门搜索换页功能"></a>热门搜索换页功能</h3><ol><li>添加换页iconfont</li></ol><ul><li>注意，页面中有多个字体图标样式修改时，我们要对每一个设定自己特定的类名！！！，避免样式冲突</li></ul><pre><code>// 例如&lt;i  className={    this.props.focused    ? "focused iconfont search"    : "iconfont search"  }&gt;  &amp;#xe637;&lt;/i&gt;&lt;i  className="iconfont spin"&gt;  &amp;#xe772;&lt;/i&gt;</code></pre><ol start="2"><li>实现分页思路</li></ol><blockquote><p>我们获取到的数据是一大堆数据数组的集合，我们可以把它们分为固定长度为一组，预定存储当前页数，和总页数两个数据在store中</p></blockquote><p><strong>index.js</strong></p><pre><code>// (1)在getListArea函数中根据page来选择数据const newList = list.toJS();    //immutable数据变为js标准数据const newList = [];if (newList.length) {    for (let i = (page-1) * 10; i &lt; page * 10; i++) {        pageList.push(            &lt;SearchInfoItem key={newList[i]}&gt;{newList[i]}&lt;/SearchInfoItem&gt;        )    }}// (2)点击事件在&lt;SearchInfoSwitch&gt;上添加onClick={() =&gt; handleChangePage(page, totalPage, this.spinIcon)}//这个点击事件需要传入三个参数，最后一个参数是对应的字体图标标签元素，这里需要使用ref属性获取！！ref={(icon) =&gt; {    this.spinIcon = icon;}}// (3)数据连接部分修改page: state.getIn(["header", "page"]),totalPage: state.getIn(["header", "totalPage"]),handleChangePage(page, totalPage, spin) {    let originAngle = +spin.style.transform.replace(/[^0-9]/gi, "");    spin.style.transform = "rotate(" + (originAngle + 360) + "deg)";    if (page &lt; totalPage) {        dispatch(actionCreators.changePage(page + 1));    } else {        dispatch(actionCreators.changePage(1));    }},</code></pre><blockquote><ul><li>String.replace方法(返回替换后的新字符串接受两个参数，一个实匹配字符串，一个是替换字符串)</li></ul><ol><li>正则表达式表示的匹配字符串</li><li>普通字符串</li></ol><pre><code>const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';const regex = /dog/gi;console.log(p.replace(regex, 'ferret'));// expected output: "The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?"console.log(p.replace('dog', 'monkey'));// expected output: "The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?"</code></pre><ul><li>正则表达式：末尾的gi表示（多次匹配，不考虑大小写）</li></ul></blockquote><p><strong>actionCreaters.js</strong></p><pre><code>// (1)添加一个changePage函数export const changePage = (page) =&gt; ({  type: actionTypes.CHANGE_PAGE,  page,});// (2)changeList中添加计算totalPage的action在异步获取数据的同时也确定了总的热门搜索的页数totalPage: Math.ceil(data.length / 10),</code></pre><ul><li>对应更改actionTypes.js</li></ul><p><strong>reducer.js</strong></p><pre><code>// changeList action添加更改获取totalPage值case actionTypes.CHANGE_LIST:  return state.merge({  list: action.data,  totalPage: action.totalPage,});// changePage action获取当前page值case actionTypes.CHANGE_PAGE:    return state.set("page", action.page);default:</code></pre><ul><li>merge方法，返回一个对象，可以修改一组immutable类型的数据。代替get链的写法</li></ul><h2 id="首页开发"><a href="#首页开发" class="headerlink" title="首页开发"></a>首页开发</h2><h3 id="路由功能使用"><a href="#路由功能使用" class="headerlink" title="路由功能使用"></a>路由功能使用</h3><ul><li>对于单页面应用，更改对应不同的路径显示不同的div，实现内容切换</li></ul><ol><li>安装</li></ol><pre><code>npm install react-router-dom</code></pre><ol start="2"><li>引入对应模块</li></ol><pre><code>import { BrowserRouter, Route } from "react-router-dom";</code></pre><ul><li>BrowserRouter是切换部分的总盒子</li><li>Route是盒子内的切换子模块</li></ul><pre><code>&lt;BrowserRouter&gt;  &lt;Route path="/" exact render={() =&gt; &lt;div&gt;home&lt;/div&gt;}&gt;&lt;/Route&gt;  &lt;Route path="/detail" exact render={() =&gt; &lt;div&gt;detail&lt;/div&gt;}&gt;&lt;/Route&gt;&lt;/BrowserRouter&gt;</code></pre><ul><li><strong>exact属性</strong>: path完全匹配（不加的话，“/detail”会识别“/”和”/detail”）</li></ul><h3 id="文件架构搭建"><a href="#文件架构搭建" class="headerlink" title="文件架构搭建"></a>文件架构搭建</h3><ol><li>新建pages文件夹<ul><li>存放各个页面</li></ul></li><li>pages文件夹下，新建detail详情页和home主页</li><li>detail和home都要创建对应的index.js和styles.js</li><li>页面内容过多可以分组件开发<ul><li>如：home下新建compoments文件夹存放主页的各个小组件</li></ul></li></ol><p><strong>App.js</strong></p><pre><code>//引入各个页面组件import Home from "./pages/home";import Detail from "./pages/detail";//Route中 component属性指向相应组件，而不是render函数&lt;Route path="/" exact component={Home}&gt;&lt;/Route&gt;&lt;Route path="/detail" exact component={Detail}&gt;&lt;/Route&gt;</code></pre><p><strong>home/index.js</strong></p><ul><li>首页分为左右两个部分</li></ul><pre><code>//home 结构&lt;HomeWrapper&gt;  &lt;HomeLeft&gt;    &lt;Topic /&gt;    &lt;List /&gt;  &lt;/HomeLeft&gt;  &lt;HomeRight&gt;    &lt;Recommend /&gt;    &lt;Writer /&gt;  &lt;/HomeRight&gt;&lt;/HomeWrapper&gt;</code></pre><h3 id="Topic部分设计"><a href="#Topic部分设计" class="headerlink" title="Topic部分设计"></a><strong>Topic部分设计</strong></h3><ul><li>在Topic.js文件中编写Topic内容</li></ul><ol><li>建立store连接</li></ol><pre><code>import { connect } from "react-redux";const mapState = (state) =&gt; ({  list: state.get("home").get("topicList"),});export default connect(mapState, null)(Topic);</code></pre><ol start="2"><li>结构样式编写</li></ol><pre><code>render() {  const { list } = this.props;  return (    &lt;TopicWrapper&gt;      {list.map((item) =&gt; (        &lt;TopicItem key={item.get("id")}&gt;          &lt;img className="topic-pic" src={item.get("imgUrl")} /&gt;          {item.get("title")}        &lt;/TopicItem&gt;      ))}    &lt;/TopicWrapper&gt;  );}</code></pre><ul><li>首页的样式都写在home文件夹下的统一style.js中</li></ul><pre><code>import { TopicWrapper, TopicItem } from "../style";</code></pre><ol start="3"><li>添加reducer.js</li></ol><pre><code>// 需要使用到topicList列表 并且引入immutableimport { fromJS } from "immutable";const defaultState = fromJS({  topicList: [    {      id: 1,      title: "社会热点",      imgUrl:        "绝对地址1",    },    {      id: 2,      title: "手绘",      imgUrl:        "绝对地址2",    },  ],});export default (state = defaultState, action) =&gt; {  switch (action.type) {    default:      return state;  }};</code></pre><h3 id="List部分设计"><a href="#List部分设计" class="headerlink" title="List部分设计"></a>List部分设计</h3><ul><li>在List.js中设计List内容    流程和上面相同</li></ul><p>分析一下就行：</p><blockquote><ul><li>页面设计三个部分：（标题，简介），图片（右）</li></ul></blockquote><pre><code>list.map((item) =&gt; {  return (    &lt;ListItem key={item.get('id')}&gt;      &lt;img alt='' className='pic' src={item.get('imgUrl')} /&gt;      &lt;ListInfo&gt;        &lt;h3 className='title'&gt;{item.get('title')}&lt;/h3&gt;        &lt;p className='desc'&gt;{item.get('desc')}&lt;/p&gt;      &lt;/ListInfo&gt;    &lt;/ListItem&gt;  );})</code></pre><blockquote><ul><li><p>connect连接数据仓库</p></li><li><p>修改reducer，</p></li><li><p>添加articleList列表数据</p></li></ul></blockquote><ul><li>其他两个模块类似完成 Recommend.js和Writer.js</li></ul><h3 id="异步获取数据"><a href="#异步获取数据" class="headerlink" title="异步获取数据"></a>异步获取数据</h3><ul><li>在home/index.js中通过componentDidMount函数实现异步axios数据请求</li></ul><pre><code>// (1) 需要引入axios模块// (2) 在componentDidMount中异步请求  componentDidMount() {    axios.get("/api/home.json").then((res) =&gt; {      const result = res.data.data;      const action = {        type: "change_home_data",        topicList: result.topicList,        articleList: result.articleList,        recommendList: result.recommendList,      };      this.props.changeHomeData(action);    });  }// (3) 这里只用对dispatch方法做连接const mapDispatch = (dispatch) =&gt; ({  changeHomeData(action) {    dispatch(action);  },});export default connect(null, mapDispatch)(Home);</code></pre><h3 id="异步操作中间件优化"><a href="#异步操作中间件优化" class="headerlink" title="异步操作中间件优化"></a>异步操作中间件优化</h3><ul><li>之前我们已经引入redux-thunk模块，所以，我们可以在actioncreators.js中异步返回函数！</li><li>并且利用生命周期函数componentDidMount异步调用执行方法changeHomeData</li></ul><blockquote><p>将异步请求放再actionCreators.js中</p><ol><li>引入axios模块</li><li>导出getHomeInfo（返回一个函数）</li><li>函数中还会带着数据再次调用dispatch方法（返回action）</li><li>dispatch方法将action派发给reducer进行处理</li></ol></blockquote><pre><code>componentDidMount() {    this.props.changeHomeData();}</code></pre><pre><code>const mapDispatch = (dispatch) =&gt; ({  changeHomeData() {    dispatch(actionCreators.getHomeInfo());  },});</code></pre><h3 id="加载更多模块设计"><a href="#加载更多模块设计" class="headerlink" title="加载更多模块设计"></a>加载更多模块设计</h3><ul><li>点击加载更多按钮，加载出更多list列表项</li></ul><ol><li>结构代码添加 <code>List.js</code></li></ol><pre><code>&lt;LoadMore onClick={() =&gt; getMoreList(page)}更多文字&lt;/LoadMore&gt;</code></pre><ol start="2"><li>样式文件添加对应样式 <code>style.js</code></li></ol><pre><code>export const LoadMore = styled.div`    width: 100%;  height: 40px;  line-height: 40px;  margin: 30px 0;  background: #a5a5a5;  text-align: center;  border-radius: 20px;  color: #fff;  cursor: pointer;`;</code></pre><ol start="3"><li>绑定<code> dispatch</code>函数</li></ol><pre><code>getMoreList(page) {    dispatch(actionCreators.getMoreList(page));},</code></pre><ol start="4"><li>修改 <code>actionCreators.js</code></li></ol><ul><li>也是异步请求，但是要加上加载的页码数</li></ul><pre><code>const addHomeList = (list, nextPage) =&gt; ({  type: actionTypes.ADD_ARTICLE_LIST,  list: fromJS(list),  nextPage,});export const getMoreList = (page) =&gt; {  return (dispatch) =&gt; {    axios.get("/api/homeList.json?page=" + page).then((res) =&gt; {      const result = res.data.data;      dispatch(addHomeList(result, page + 1));    });  };};</code></pre><ol start="5"><li>reducer.js</li></ol><ul><li>添加处理程序</li></ul><pre><code>case actionTypes.ADD_ARTICLE_LIST:    return state.merge({        articleList: state.get("articleList").concat(action.list),        articlePage: action.nextPage,});</code></pre><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol><li><p>react-redux使用connect连接store和页面，一旦store改变了，就会重新渲染使用connect所连接的所有render部分。</p><blockquote><ul><li>为解决这样的性能消耗，react帮我们预定义了一个纯组件<code>PureComponent</code></li></ul><p>其中相当于内置了<strong>shouldComponentUpdate</strong>这个生命周期函数！！，进行一层浅比较，所以对于一些引用数据类型可能会有坑，但对于使用immutable.js管理的数据，可以得到很好的兼容性！！！</p></blockquote></li><li><p>单页面跳转</p><blockquote><ul><li>在react-router-dom中有一个<code>Link</code>组件  <code>to</code> 属性可以实现单页面跳转功能</li></ul><pre><code>//使用方法 ：外面加一个&lt;Link to="/"&gt;    //回到根页面   ....&lt;/Link&gt;</code></pre><p><strong>注意点</strong>：使用路由跳转的组件都应该放在<code>&lt;BrowserRouter&gt;</code>组件内部</p></blockquote></li></ol><h2 id="详情页-登录功能开发"><a href="#详情页-登录功能开发" class="headerlink" title="详情页/登录功能开发"></a>详情页/登录功能开发</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> js_React </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型</title>
      <link href="2020/10/29/shu-ju-lei-xing/"/>
      <url>2020/10/29/shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h2><ul><li>7种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 和 <code>undefined</code>。</li><li>对象</li><li>除了 <code>null</code> 和 <code>undefined</code> 以外的原始类型都提供了许多有用的方法</li><li>形式上，构造器方法，内置方法通过临时对象工作</li></ul><p><strong>实例</strong></p><ul><li>原始对象不是对象，不能额外存储数据</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//问？ 返回结果是什么</span><span class="token comment" spellcheck="true">// (1)undefined（非严格模式）</span><span class="token comment" spellcheck="true">// (2)报错（严格模式）</span><span class="token comment" spellcheck="true">// 分析：</span><span class="token comment" spellcheck="true">// 1. 当我们访问str属性时，一个‘对象包装器‘被创建</span><span class="token comment" spellcheck="true">// 2. 严格模式下，写入内容会报错</span><span class="token comment" spellcheck="true">// 3. 否则，会执行属性操作，对象获得test属性，但使用完’对象包装器消失‘，因此str并没有这个属性</span></code></pre><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>number有两种类型</p><ol><li>js中常规数字以64位的格式IEEE-754存储，也就是“双精度浮点数”，常规数字不能超过 <code>2e53</code> 或小于 <code>-2e53</code>。</li><li>BigInt数字，表示任意长度的<strong>整数</strong></li></ol><h4 id="编写数字的更多方法"><a href="#编写数字的更多方法" class="headerlink" title="编写数字的更多方法"></a>编写数字的更多方法</h4><ul><li>表示10亿<ol><li><code>let billion = 1000000000;</code></li><li><code>let billion = 10e9;</code></li><li><code>let billion = 1bn;</code></li></ol></li><li>进制<ol><li>16进制：<code>0xff</code>,一般用于表示颜色，编码字符等</li><li>8进制： <code>0o377</code>,八进制255</li><li>2进制：<code>0b11111111</code>,二进制255</li><li>其他进制使用，<code>parseInt</code></li></ol></li></ul><h4 id="toString-base"><a href="#toString-base" class="headerlink" title="toString(base)"></a>toString(base)</h4><ul><li>返回给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//例子</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ff</span><span class="token function">alert</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 11111111</span></code></pre><ul><li><p><code>base </code>范围可以从 <code>2</code> 到 <code>36</code>。默认情况下是 <code>10</code>。</p></li><li><p><strong>base=36</strong> 是最大进制，数字可以是 <code>0..9</code> 或 <code>A..Z</code>。例如，做一个短的URL，可以使用基数为36的数字系统表示</p><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span> <span class="token number">123456</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//2n9c</span><span class="token comment" spellcheck="true">//也可写为</span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><strong>使用两点调用一个方法</strong>：注意，数字后一个点表示后面是小数部分，两个点就表明无小数部分，直接调用后面的方法</li></ul></li></ul><h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><ul><li>对数字进行舍入（rounding）的内建函数</li></ul><ol><li><code>Math.floor</code>:向下舍入</li><li><code>Math.ceil</code>:向上舍入</li><li><code>Math.round</code>:向最近的整数舍入</li><li><code>Math.trunc</code>:移除小数点后的内容，不舍入</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> js_数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="2020/10/29/ajax/"/>
      <url>2020/10/29/ajax/</url>
      
        <content type="html"><![CDATA[<ul><li>Ajax是一种无需重新加载整个网页的情况下，能够更新部分网页的技术</li></ul><h2 id="Ajax-基础"><a href="#Ajax-基础" class="headerlink" title="Ajax 基础"></a>Ajax 基础</h2><h4 id="什么是Ajax？"><a href="#什么是Ajax？" class="headerlink" title="什么是Ajax？"></a>什么是Ajax？</h4><ul><li><p>Ajax = 异步js 和 XML</p></li><li><p>一种创建快速动态网页的技术</p></li><li><p>通过在后台和服务器进行少量数据交换，Ajax可以使网页实现异步更新，即，不重新加载整个网页的情况下，对页面某部分进行更新</p></li><li><p>应用实例：新浪微博，Google地图。。</p></li></ul><h4 id="Google-Suggest"><a href="#Google-Suggest" class="headerlink" title="Google Suggest"></a>Google Suggest</h4><ul><li>搜索框输入关键词，js会把这些字符发送到服务器，然后服务器返回一个搜索列表</li><li>也就是Ajax，非常常见的用处</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>react进阶</title>
      <link href="2020/10/24/react-jin-jie/"/>
      <url>2020/10/24/react-jin-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="深入理解create-react-app"><a href="#深入理解create-react-app" class="headerlink" title="深入理解create-react-app"></a>深入理解<code>create-react-app</code></h2><ul><li>这是一个官方文档提供的新手使用的脚手架</li></ul><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><pre><code>npx create-react-app my-app</code></pre><ul><li>在目标文件夹下打开shell命令行工具，写入上述语句，就可以在当前目录下新建一个react工程文件</li></ul><h3 id="工程目录解析"><a href="#工程目录解析" class="headerlink" title="工程目录解析"></a>工程目录解析</h3><ul><li>新建工程目录如下</li></ul><img src="/2020/10/24/react-jin-jie/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90.png" class="" title="文件目录解析"><blockquote><ol><li><p><code>package-lock.josn</code>:项目依赖的安装包版本号</p></li><li><p><code>package.json</code>:node的包文件，可以让项目变为一个包,也安装了react，供<code>.js</code>文件引用</p></li><li><p><code>gitignore</code>:不想传到git仓库的文件可以放在这里</p></li><li><p>src:</p><ul><li><p>index.js：程序的运行入口</p><pre><code>import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from '.App';//import reportWebVitals from './reportWebVitals';//reportWebVitals();//上面两个是一对用于PWA，增强web app功能//还可以用相同的引入格式，引入其他文件</code></pre></li><li><p>index.css：文件样式</p></li><li><p>App.js: </p><pre><code>improt './App.css';        //头部，等引入文件...export default App;        //引出文件，提供给别的.js文件引用</code></pre></li><li><p>App.test.js: 自动化测试文件（函数式编程）</p></li></ul></li><li><p>public:</p><ul><li>index.html:</li><li>favicon.ico</li><li>manifest.json:定义快捷方式的图标（和pwa相配）</li></ul></li><li><p>node_modules:第三方的包，</p></li></ol></blockquote><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h3><h5 id="Component基类"><a href="#Component基类" class="headerlink" title="Component基类"></a>Component基类</h5><pre class=" language-js"><code class="language-js">improt <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于,下面两句语句</span><span class="token comment" spellcheck="true">//import React from 'react';</span><span class="token comment" spellcheck="true">//const Component = React.Component;</span></code></pre><ul><li>定义组件需要继承React.Component</li></ul><pre><code>import React from "react";class App extends React.Component {  render() {    return &lt;div&gt;hello&lt;/div&gt;;  }}export default App;</code></pre><h5 id="主文件下"><a href="#主文件下" class="headerlink" title="主文件下"></a>主文件下</h5><ol><li>引用<code>import ReactDOM from 'react-dom';</code></li></ol><ul><li><p>ReactDOM用法</p></li><li><p>他是一个第三方组件，调用<code>render方法</code>将我们定义的组件挂载到html页面中</p></li></ul><pre><code>ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));</code></pre><ol start="2"><li>引入<code>import React from 'react';</code></li></ol><ul><li><p>React中包含<code>JSX</code>语法</p><blockquote><p><code>&lt;App /&gt;</code>：标签式语法</p><p><code>render(){}</code>: 函数中的标签也是JSX语法</p></blockquote></li></ul><h5 id="补充：简单jsx语法"><a href="#补充：简单jsx语法" class="headerlink" title="补充：简单jsx语法"></a>补充：简单jsx语法</h5><ol><li><p>支持.js文件中写类似H5的标签语法</p><blockquote><ul><li>大写字母开头，一般都是JSX语法定义的自定义组件</li><li>小写字母开头，一般是H5标签</li></ul></blockquote></li><li><p>jsx语法规定：外层必须要有一个div包裹内部的平级标签</p><blockquote><p>当然可以引入react中的<code>Fragment</code> 来代替外层div标签</p><pre><code>import React, { Component, Fragment } from 'react';//render return内部就可以&lt;Fragment&gt;    ....&lt;/Fragment&gt;</code></pre></blockquote></li></ol><h3 id="TodoList"><a href="#TodoList" class="headerlink" title="TodoList"></a>TodoList</h3><ol><li><p>如何实现组件化开发？</p></li><li><p>如何实现向子组件传递参数？</p></li><li><p>如何反馈父组件/调用父组件的函数？</p></li><li><p>如何理清函数的this指向问题？</p><blockquote><ul><li>箭头函数this指向，箭头函数定义的作用于下</li><li>不同函数的this指向，函数由那个对象调用</li></ul></blockquote></li><li><p>如何解决map，list中key的添加？</p></li><li><p>react中特殊属性？</p><blockquote><ol><li>label标签中<code>for id</code>的使用区别</li></ol><ul><li>由于for关键词的冲突，改用<code>htmlFor="..."</code></li><li>对应input标签，仍然是<code>id="...."</code></li></ul><ol start="2"><li>防止转义的属性</li></ol><ul><li><code>dangerouslySetInnerHTML={{__html: item}}</code></li><li>item内容中的html标签内容非自动转移</li></ul></blockquote></li><li><p>如何优化代码结构？</p><blockquote><ul><li>结构化赋值<code>{content}=this.props</code>等价于<code>{this.props.content}</code></li><li>样式文件引入放在后面</li><li>组件初始化的时候就将函数<code>this</code> 指向改好</li><li>JSX体积过大，尽量拆分代码，用函数替换</li><li><code>this.setState</code> 改变状态时，使用<code>prevState</code>代替<code>this.state</code>;使用箭头函数的写法（加括号，简写return；不加括号写函数体）</li><li>使用列表时，注意key值（唯一性），（放在最外层）</li></ul></blockquote></li></ol><h3 id="react的思考"><a href="#react的思考" class="headerlink" title="react的思考"></a>react的思考</h3><ol><li>声明式开发</li><li>可以和其他框架并存</li><li>组件化</li><li>单向数据流</li><li>视图层框架</li><li>函数式编程</li></ol><h2 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h2><h3 id="PropTypes与DefaultProps"><a href="#PropTypes与DefaultProps" class="headerlink" title="PropTypes与DefaultProps"></a>PropTypes与DefaultProps</h3><ul><li>做组件接受属性时的强校验</li></ul><ol><li><p>引入PropTypes</p><pre><code>import PropTypes from 'prop-types'</code></pre></li><li><p>对属性进行强校验</p><pre><code>//PropTypes可以限制传值的类型//限制对象中没有对应属性时，就不会校验也不会报错TodoItem.propTypes = {    content: PropTypes.string,    deleteItem: PropTypes.func,    index: PropTypes.number}</code></pre></li><li><p>强制传值</p><pre><code>// isRequired强制传值，如果没有就会报错test: PropTypes.string.isRequired,</code></pre></li><li><p>默认值</p><pre><code>// defalultProps 设置传值属性的默认值TodoItem.defaultProps = {    test: 'hello world',}</code></pre></li></ol><ul><li>其他用法</li></ul><ol><li><p>PropTypes/.oneOfType([ ])</p><pre><code>//一个对象可以是几种类型中的任意一种optionalUnion: PropTypes.oneOfType([    PropsTypes.string,    PropsTypes.number,    PropsTypes.instanceof(Message),])</code></pre></li><li><p>PropTypes.element</p><pre><code>// 确保传递给组件的children只包含一个元素MyComponent.propTypes = {  children: PropTypes.element.isRequired};</code></pre></li><li><p>PropTypes.arrayOf(PropTypes.number)</p><pre><code>// 指定一个数组由某种类型的元素组成optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</code></pre></li></ol><h3 id="props-state-render之间的关系"><a href="#props-state-render之间的关系" class="headerlink" title="props,state,render之间的关系"></a>props,state,render之间的关系</h3><ul><li>当组件state和props发生变化时，render函数就会被重新执行</li><li>当父组件的render函数被执行时，子组件的render也会被重新执行</li></ul><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><ul><li><p>一般的生成修改DOM的流程</p><blockquote><ol><li>state数据</li><li>JSX模板</li><li>数据 + 模板 生成真实的DOM，并显示出来</li><li>state发生变化</li><li>数据 + 模板 生成新的DOM替换原始的DOM</li></ol></blockquote></li></ul><p>缺陷：生成了两次DOM，替换了一次DOM十分耗性能</p><ul><li><p>改进方案</p><blockquote><ol><li>state数据</li><li>JSX模板</li><li>数据 + 模板 生成真实的DOM，并显示出来</li><li>state发生变化</li><li>数据 + 模板 生成新的DOM，不直接替换，而是和原始的比对，找差异</li><li>找到对应的差异部分，用新的DOM差异部分替换</li></ol></blockquote></li></ul><p>缺点：性能提升不明显</p><ul><li><p><strong>虚拟DOM</strong></p><blockquote><ol><li><p>state数据</p></li><li><p>JSX模板</p></li><li><p>生成虚拟DOM（虚拟DOM就是一个<strong>JS对象</strong>）</p></li><li><p>数据 + 模板 生成真实的DOM，并显示出来</p><p>eg:<code>['div', {id: 'abc'}, ['span', {}, 'hello world']]</code></p></li><li><p>state发生改变</p></li><li><p>数据 + 模板 生成新的虚拟DOM（<strong>极大性能的 提升</strong>）</p><p>eg:<code>['div', {id: 'abc'}, ['span', {}, 'hello minyue']]</code></p></li><li><p>比较原始虚拟DOM和新生成的虚拟DOM，找到区别（<strong>极大提升性能</strong>）</p></li><li><p>直接操作DOM,改变对应不同点</p></li></ol></blockquote></li><li><p><strong>JSX代码转换为真实DOM的历程</strong></p></li></ul><pre><code>JSX -&gt; createElement -&gt; 虚拟DOM（JS对象） -&gt; 渲染为真实DOM// 下面两种写法等价return &lt;div&gt; {index} &lt;/div&gt;return React.createElement('div', {}, 'index');</code></pre><ul><li><p><strong>虚拟DOM的优点</strong></p><blockquote><ol><li>性能提升了</li><li>跨段应用得以实现，React Native（虚拟DOM可以被转换为原生的组件，在移动端使用）</li></ol></blockquote></li><li><p>虚拟DOM是如何比对的呢—<strong>diff算法</strong></p><blockquote><ol><li>从头开始，同级比对</li></ol><ul><li>如果某一级的内容出现差异，就直接替换下面所有内容</li></ul><ol start="2"><li>key值的重要性</li></ol><ul><li>虚拟DOM比对时，对列表数据就可以只比较数据的 key值是否对应相等，提升比对性能</li></ul><ol start="3"><li>补充</li></ol><ul><li>setState方法的异步设定的意义也在于，减少虚拟DOM比对的频繁性，提升性能</li></ul></blockquote></li></ul><h3 id="ref使用"><a href="#ref使用" class="headerlink" title="ref使用"></a>ref使用</h3><p>在input组件中<code>onChange</code> 属性调用的<code>handleInputChange(e)</code>输入参数使用<code>e.target</code> 就能获取对应inputDOM元素</p><ul><li>在react中是怎么获取DOM元素的呢？</li></ul><p>没错就是使用<code>ref</code> </p><pre><code>// 在input框架中添加属性refref={(input) =&gt; {this.input = input}// 之后我们就可以在handleInputChange函数中this.input.value    //代替原来的e.target</code></pre><ul><li><strong>使用注意点</strong></li></ul><p>在ref使用时会和setState函数产生矛盾，因为setState函数是异步的，所以就有可能获取到的DOM元素是状态还没有改变前的内容，那么有什么解决办法呢？</p><pre><code>// 使用异步函数setState的回调函数，来获取DOM// 回调函数中，确保setState已经执行this.setState((prevState) =&gt; ({    list: [...prevState, prevState.inputValue],    inputValue: ''}), () =&gt; {    console.log(this.ul.querySelectorAll('div').length);})</code></pre><ul><li>当然，React面向数据的操作，建议我们少直接操作DOM！！</li></ul><h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><ul><li><p>生命周期函数是指，某一时刻组件会自动调用执行的函数</p><blockquote><p>render  当数据发生变化时，会自动执行</p><p>constructor 初始化时自动执行的函数</p></blockquote></li></ul><img src="/2020/10/24/react-jin-jie/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png" class="" title="生命周期函数"><p><strong>分模块解释</strong></p><blockquote><ol><li>Initialization 初始化</li></ol><ul><li>constructor中的props和state</li></ul><ol start="2"><li>Mounting 挂载</li></ol><ul><li>componentWillMount </li><li>render 页面第一次挂载</li><li>componentDidMount</li></ul><ol start="3"><li>Updation 更新</li></ol><ul><li><p>props</p><ul><li>componentWillReceiveProps（对子组件有用）<ol><li>子组件接受父组件的props </li><li>组件非第一次存在父组件，才会执行</li></ol></li><li>shouldComponentUpdate（是否更新）<ol><li>需要返回一个布尔值</li><li>true才会执行后面的步骤</li></ol></li><li>componentWillUpdate（编译前执行）</li><li>render</li><li>componentDidUpdate（编译后执行）</li></ul></li><li><p>states  没有第一步</p></li><li><p>每一个组件都有自己的生命周期函数！！</p></li></ul></blockquote><h3 id="生命周期函数使用场景"><a href="#生命周期函数使用场景" class="headerlink" title="生命周期函数使用场景"></a>生命周期函数使用场景</h3><ul><li>render不可缺少<ul><li>由于组件都是继承于<code>Component</code> ，其中都内置了其余的生命周期函数，但唯一没有<code>render</code></li></ul></li></ul><h4 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h4><blockquote><p>之前我们需要的提升性能的点：</p><ol><li>函数作用域绑定在constructor中完成</li><li>列表key值的绑定，diff算法</li><li>setState异步函数</li></ol></blockquote><ul><li><p><strong>shouldComponentUpdate使用</strong></p><ul><li>我们都知道，父组件render函数改变时，会连带子组件的render函数也重新渲染，但是当我们没有提交改变内容时，我们不需要子组件渲染，如何解决？</li><li>使用这个生命周期函数，停止渲染</li></ul><pre><code>shouldComponentUpdate(nextProps, nextState) {    if(nextProps.content !== this.props.content) {        return true;    } else {        return false;    }}</code></pre></li></ul><h4 id="发送ajax请求"><a href="#发送ajax请求" class="headerlink" title="发送ajax请求"></a>发送ajax请求</h4><blockquote><p>在网页不重载的情况下，改变网页内容，ajax请求只用一次，获取到数据留用就行了，所以找一个有且执行一次的生命周期函数</p><ul><li>componentWillMount，constructor等有些些不便的原因（其他端产生冲突）</li></ul></blockquote><ol><li>首先，在react中发送ajax请求需要安装第三方插件</li></ol><pre><code>npm install axios//安装之后重新打开项目npm start</code></pre><ol start="2"><li>在页面中引入axios组件</li></ol><pre><code>import axios from "axios";</code></pre><ol start="3"><li>**componentDidMount()**中添加请求</li></ol><pre><code>componentDidMount() {    axios.get('/api/todolist')        .then(()=&gt;alert('success'))        .catch(()=&gt;alert('error'));}</code></pre><ul><li>显然没有这个接口，返回弹窗error，在network中可以看到确实发送了请求，返回<code>404</code></li></ul><h3 id="使用fiddler实现本地数据mock"><a href="#使用fiddler实现本地数据mock" class="headerlink" title="使用fiddler实现本地数据mock"></a>使用fiddler实现本地数据mock</h3><ul><li>前后端分离的开发，让前端人员要自己模拟后端数据，这里我们使用fiddler工具</li></ul><blockquote><ul><li><p>新建一个.json文件，放入数据</p></li><li><p>刷新react项目页面，可以找到请求的链接</p></li><li><p>双击该请求，在右方详情页中选择AutoResponder,然后勾选前两个复选框Enable rules和Unmatched requests passthrough,点击Add Rule，在Rule Editor的第二个input框中复制本地文件链接，点击save，勾选下方的If request中新建的rule</p></li></ul></blockquote><pre><code>//简单的使用：将数据默认显示在list中componentDidMount() {    axios        .get("/api/todolist")        .then((res)=&gt;{            this.setState(()=&gt;({list:[...res.list]}));        })        .catch(()=&gt;alert("error"));}</code></pre>  <img src="/2020/10/24/react-jin-jie/fiddler.png" class="" title="fiddler"><h3 id="React实现CSS过渡效果"><a href="#React实现CSS过渡效果" class="headerlink" title="React实现CSS过渡效果"></a>React实现CSS过渡效果</h3><ul><li><p>这里过渡效果以交替呈现的示例就引入<code>.css</code> 文件</p><blockquote><p>写入两个类一个描述透明度<code>.show,</code>一个描述<code>.hide</code></p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.show</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">1</span>s ease-in<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.hide</span> </span><span class="token punctuation">{</span>  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">1</span>s ease-in<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></blockquote></li><li><p>在<code>js</code>文件中</p><blockquote><ol><li>state中创建一个布尔变量属性</li><li>按钮，对state的布尔值改变</li><li>对应className就根据state变量改变样式类</li></ol></blockquote></li></ul><h3 id="React使用CSS动画效果"><a href="#React使用CSS动画效果" class="headerlink" title="React使用CSS动画效果"></a>React使用CSS动画效果</h3><ul><li>动画效果就是引入动画模块<code>@keyframes</code>，<code>animation</code>属性</li><li><strong>值得注意的地方</strong>：加上<code>forwards</code>(保留最后一帧动画效果)</li></ul><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.show</span> </span><span class="token punctuation">{</span>  <span class="token property">animation</span><span class="token punctuation">:</span> show-item <span class="token number">2</span>s ease-in forwards<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.hide</span> </span><span class="token punctuation">{</span>  <span class="token property">animation</span><span class="token punctuation">:</span> hide-item <span class="token number">2</span>s ease-in forwards<span class="token punctuation">;</span><span class="token punctuation">}</span>//show-item 同下//<span class="token number">....</span><span class="token atrule"><span class="token rule">@keyframes</span> hide-item</span> <span class="token punctuation">{</span>  <span class="token selector">0% </span><span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">50% </span><span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">100% </span><span class="token punctuation">{</span>    <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="使用React-transition-group"><a href="#使用React-transition-group" class="headerlink" title="使用React-transition-group"></a>使用React-transition-group</h3><ul><li>进入github，搜索<a href="https://reactcommunity.org/react-transition-group/">React-transition-group</a></li></ul><ol><li><p>安装这个模块</p><pre><code>npm install react-transition-group --save</code></pre></li><li><p>引入这个模块</p><pre><code>import { CSSTransition } from 'react-transition-group';</code></pre></li><li><p>使用<code>&lt;CSSTransition&gt; &lt;/CSSTransition&gt;</code>包裹需要样式的”html元素”</p><ul><li><p>他帮助我们完成样式的更改添加</p></li><li><p>注意他的属性！！！</p><blockquote><ul><li> in={this.state.show}: 动画执行的标志</li><li> timeout={1000}：动画执行时长</li><li>classNames=”fade”：类名前缀</li><li>unmountOnExit：exit后动画元素删除</li><li>appear={true}： 首次渲染时也添加动画</li></ul></blockquote></li></ul><pre><code>&lt;CSSTransition    in={this.state.show}    timeout={1000}  classNames="fade"  unmountOnExit  appear={true}    &gt;    &lt;div&gt;hello&lt;/div&gt;&lt;/CSSTransition&gt;</code></pre></li></ol><pre class=" language-css"><code class="language-css">   <span class="token selector">//对应CSS文件   //存在enter和exit就可以了   //如果appear=</span><span class="token punctuation">{</span>true<span class="token punctuation">}</span><span class="token selector">，就加上<span class="token class">.fade-appear</span>等类   <span class="token class">.fade-enter</span>,   <span class="token class">.fade-appear</span> </span><span class="token punctuation">{</span>     <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token selector"><span class="token class">.fade-enter-active</span>,   <span class="token class">.fade-appear-active</span> </span><span class="token punctuation">{</span>     <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">1</span>s ease-in<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token selector"><span class="token class">.fade-enter-done</span>,   <span class="token class">.fade-appear-done</span> </span><span class="token punctuation">{</span>     <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token selector"><span class="token class">.fade-exit</span> </span><span class="token punctuation">{</span>     <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token selector"><span class="token class">.fade-exit-active</span> </span><span class="token punctuation">{</span>     <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">1</span>s ease-in<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token selector"><span class="token class">.fade-exit-done</span> </span><span class="token punctuation">{</span>     <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><ul><li><p>另外，一些<strong>钩子函数</strong></p><blockquote><p><strong>也是添加在属性中</strong></p><p>钩子：和生命周期函数一样的，特定时间发生！！</p><ol><li>onEnter</li></ol><ul><li>进入的第一时刻</li></ul><ol start="2"><li>onEntering</li></ol><ul><li>进入的动画时间</li></ul><ol start="3"><li>onEntered</li></ol><ul><li>进入结束时</li></ul><pre><code>//进入结束后出发的函数onEntered={(er)=&gt;{el.style.color='blue'}}</code></pre><ul><li>同样对于exit</li></ul></blockquote></li></ul><ol start="4"><li><strong>TransitionGroup</strong></li></ol><ul><li><p>对于一组一组的添加动画效果时，需要配合<code>TransitionGroup</code> 使用</p><blockquote><ul><li>下面以点击按钮，添加item的一组效果</li></ul><ol><li>这里就要把show改为list</li><li>点击按钮，函数操作改为在原有list末尾添加一个元素</li><li>样式部分<code>&lt;TransitionGroup&gt;</code>放在list遍历外部，<code>&lt;CSSTransition&gt;</code>放在对应小组件的外层</li></ol></blockquote><img src="/2020/10/24/react-jin-jie/TransitionGroup.png" class="" title="TransitionGroup"></li></ul><h2 id="Redux入门"><a href="#Redux入门" class="headerlink" title="Redux入门"></a>Redux入门</h2><ul><li>和react配套使用的数据层框架</li><li>使用redux，我们将数据都存放在Store中，当一个组件改变了Stroe中的数据，其他组件就会自动感知数据的变化做出反应</li></ul><h3 id="Redux工作流"><a href="#Redux工作流" class="headerlink" title="Redux工作流"></a>Redux工作流</h3> <img src="/2020/10/24/react-jin-jie/Redux.png" class="" title="Redux"><ul><li>举例把这个流程理解成图书馆的流程</li></ul><ol><li>react component：借书的人</li><li>action creaters：询问管理员要借哪一本书</li><li>store：图书管理员</li><li>reducers：图书管理员的记录资料</li></ol><h3 id="Antd页面布局"><a href="#Antd页面布局" class="headerlink" title="Antd页面布局"></a>Antd页面布局</h3><ul><li><a href="https://ant.design/components/overview-cn/">官网地址</a></li></ul><ol><li><p>安装</p><pre><code>//使用npm$ npm install antd --save</code></pre></li><li><p>简单使用</p><blockquote><ul><li><p>引用样式和你所需要的组件</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token string">"antd/dist/antd.css"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Input<span class="token punctuation">,</span> Button<span class="token punctuation">,</span> List <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"antd"</span><span class="token punctuation">;</span></code></pre></li><li><p>根据文档中的使用代码方法使用就可以了</p></li></ul></blockquote></li></ol><h3 id="redux中的store"><a href="#redux中的store" class="headerlink" title="redux中的store"></a>redux中的store</h3><ol><li>安装redux核心库</li></ol><pre><code>npm install redux</code></pre><ol start="2"><li><p>在项目src目录下创建store文件夹</p><ul><li>index.js(存储仓库，图书管理员)</li></ul><pre><code>//引入创建库的函数//引入reducerimport { createStore } from 'redux';import reducer from './reducer';const store = createStore(reducer);export default store;</code></pre><ul><li>reducter.js(图书记录本)</li></ul><pre><code>//返回一个函数//state:图书馆书籍信息,有一个默认值//action:一个个借书操作const defaultState = {    inputValue = '',    list: []}export default (state = defaultState, action) = {    return state;}</code></pre></li><li><p>在容器组件中引入store</p><pre><code>//文件目录下的index.js文件可以默认不写import store from './store';</code></pre></li><li><p>引用数据 <code>getStore()</code></p><pre><code>//返回一个存有数据的对象this.state = store.getStore()</code></pre></li><li><p>发送action <code>store.dispatch(action)</code></p><pre><code>//写一个实例函数handleInputChange(e) {    const action = {        type: 'change_input_value',        value: e.target.value,    }    store.dispatch(action)}</code></pre></li><li><p>reducer处理程序</p><pre><code>//reducer的函数中处理对应的action//reducer需要深拷贝state//store中的数据，由返回的newState在index.js中替换旧state时，才被修改if(action === 'change_input_value') {    const newState = JSON.parse(JSON.stringify(state));    newState.inputValue = action.value;    return newState;}</code></pre></li><li><p>容器组件中同步store数据的修改</p><pre><code>//constructor中监视store的改变store.subscribe(this.handleStore);//函数功能：替换statehandleStore() {    this.setState(store.getStore());}</code></pre></li></ol><ul><li><strong>其他功能类似</strong></li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ol><li><p><strong>actionTypes.js</strong></p><ul><li>集中管理各个action名称（避免书写错误带来的麻烦）</li></ul><pre><code>//store目录下新建一个actionTpes.jsexport const CHANGE_INPUT_VALUE = 'change_input_value'.....//使用时，引入import { CHANGE_INPUT_VALUE } from 'src'</code></pre></li><li><p><strong>actionCreater.js</strong></p><ul><li>集中管理action</li></ul><pre class=" language-react"><code class="language-react">//对每一个action对象，都进行这样的封装，返回一个对象export const getInputChangeAction = (value) => ({    type: CHANGE_INPUT_VALUE,    value});//使用时import { getInputChangeAction } from 'src';handleInputChange(e) {    const action = getInputChangeAction(e.target.value);    store.dispatch(action);}</code></pre></li></ol><h3 id="redux总结"><a href="#redux总结" class="headerlink" title="redux总结"></a>redux总结</h3><ol><li><p>store是惟一的，也只有index.js中才能改变store中的数据</p></li><li><p>reducer是一个纯函数，（给定输入，一定有固定输出，而且不会产生副作用）</p></li><li><p>核心API</p><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>createStore</td><td>index.js创建仓库</td></tr><tr><td>store.dispatch</td><td>传递action</td></tr><tr><td>store.getState</td><td>获取store数据对象</td></tr><tr><td>store.subscribe</td><td>捕捉store改变</td></tr></tbody></table></li></ol><h2 id="Redux进阶"><a href="#Redux进阶" class="headerlink" title="Redux进阶"></a>Redux进阶</h2><h3 id="UI组件-容器组件-无状态组件"><a href="#UI组件-容器组件-无状态组件" class="headerlink" title="UI组件/容器组件/无状态组件"></a>UI组件/容器组件/无状态组件</h3><ul><li>一个负责逻辑，一个负责渲染</li><li>无状态组件就是函数组件，性能更好</li></ul><blockquote><p>将渲染部分（render函数内部）独立出来一个分支</p><p><strong>TodoListUI.js</strong></p></blockquote><pre class=" language-react"><code class="language-react">//引入样式文件和react文件import { Input, Button, List } from "antd";import React from "react";//仅仅只负责渲染我们可以使用无状态组件（无需创建类）//箭头函数输入props，就使用props代替this.propsconst TodoListUI = (props) => {    return (        .....//JSX语法        );};//对应render函数render() {    return(        <TodoListUI       inputValue={this.state.inputValue}       list={this.state.list}       handleInputChange={this.handleInputChange}       handleClickBtn={this.handleClickBtn}       handleDeleteItem={this.handleDeleteItem}     />    );}</code></pre><h3 id="redux-thunk-中间件实现ajax请求"><a href="#redux-thunk-中间件实现ajax请求" class="headerlink" title="redux-thunk 中间件实现ajax请求"></a>redux-thunk 中间件实现ajax请求</h3><ul><li>之前我们使用ajax请求，是将代码放在componentDidMount函数中</li><li>但是当异步操作变多时，函数中的代码就会变得多到难以调试</li></ul><blockquote><p>我们引入这个中间件来时我们</p></blockquote><ol><li><p>首先下载这个中间件包</p><pre><code>npm install redux-thunk;</code></pre></li><li><p>解决和redux并行使用的问题</p><pre class=" language-react"><code class="language-react">//在github中 redux-devtools文档中//引入thunk包，compose等api//import { createStore, applyMiddleware, compose } from "redux";import thunk from "redux-thunk";const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__  ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({})  : compose;const enhancer = composeEnhancers(applyMiddleware(thunk));const store = createStore(reducer, enhancer);export default store;</code></pre></li><li><p>actionCreater中实现异步函数调用</p><pre class=" language-react"><code class="language-react">//返回的getTodoList()是一个函数//并且这个函数接受了前面传来的dispatchexport const initListAction = (data) => ({  type: INIT_LIST_ACTION,  data,});export const getTodoList = () => {  return (dispatch) => {    axios.get("/api/todolist").then((res) => {      const data = res.data;      const action = initListAction(data);      dispatch(action);    });  };};</code></pre></li><li><p>componentDidMount</p><pre class=" language-react"><code class="language-react">//因为有redux-thunk存在，action可以是一个函数//在第5句中自动执行该函数（并且引入dispatch参数）componentDidMount() {  const action = getTodoList();  store.dispatch(action);}</code></pre></li></ol><h3 id="redux-saga中间件异步操作"><a href="#redux-saga中间件异步操作" class="headerlink" title="redux-saga中间件异步操作"></a>redux-saga中间件异步操作</h3><ol><li><p>安装</p><pre><code>$ npm install redux-saga</code></pre></li><li><p>store目录下新建一个<code>sagas.js</code></p><pre><code>function* mySaga() {  //...}export default mySaga;</code></pre></li><li><p>index.js文件中引入中间件</p><pre class=" language-react"><code class="language-react">//和thunk很像，仿照官方文档import { createStore, applyMiddleware, compose } from "redux";import reducer from "./reducer";import createSagaMiddleware from "redux-saga";import mySaga from "./sagas";// create the saga middlewareconst sagaMiddleware = createSagaMiddleware();const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__  ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({})  : compose;const enhancer = composeEnhancers(applyMiddleware(sagaMiddleware));const store = createStore(reducer, enhancer);sagaMiddleware.run(mySaga);export default store;</code></pre></li><li><p>componentDidMount</p><pre class=" language-react"><code class="language-react">//和原生用法类似const action = getInitList();store.dispatch(action);</code></pre></li><li><p>actionCreater</p><pre class=" language-react"><code class="language-react">//创建对应的action对象//但注意这个action的处理程序不在reducer，而在sagas.js中export const getInitList = () => ({  type: GET_INIT_LIST,});</code></pre></li><li><p>sagas.js文件</p><pre class=" language-react"><code class="language-react">// 参照官方文档import { takeEvery, put } from "redux-saga/effects";import { GET_INIT_LIST } from "./actionType";import axios from "axios";import { initListAction } from "./actionCreater";function* getInitList() {  try {    const res = yield axios.get("/api/todolist");    const action = initListAction(res.data);    yield put(action);  } catch (e) {    console.log("404");  }}//generator函数 书写形式//takeEvery可以捕获每一次的action类型//下面函数功能：一旦接受到GET_INIT_LIST类型的action时//就会执行fetchUser方法function* mySaga() {  yield takeEvery(GET_INIT_LIST, getInitList);}export default mySaga;</code></pre></li></ol><ul><li>将异步处理程序迁移到<code>sagas.js</code>文件中处理</li></ul><h3 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h3><ul><li><p>在action和store中间，对store的dispatch方法的升级</p></li><li><p>thunk中间件，action可以是一个函数 并接收一个dispath函数，dispatch会让其异步执行；当然如果不是函数就按原逻辑执行</p></li><li><p>redux-log：对dispatch每次派发的时候进行console.log()，即打印日志</p></li><li><p>redux-saga：单独对异步逻辑拆分出来放在一个文件管理</p><img src="/2020/10/24/react-jin-jie/redux%E4%B8%AD%E9%97%B4%E4%BB%B6.png" class="" title="redux中间件"></li></ul><blockquote><p><strong>流程分析</strong></p><ol><li><p>thunk 中间件</p><blockquote><p>dispatch一个action<br>action可以是一个函数 并接收一个dispath函数<br>可以在action的函数中进行异步操作<br>接受到数据后再dispatch一个action 此action必须是一个对象包含type和数据<br>reducer拦截到action的type和数据返回新的state</p></blockquote></li><li><p>saga 中间件</p><blockquote><p>dispatch一个action<br>action只能是对象 并且type必须是reducer没有的<br>sagas.js拦截此type并执行另一个函数进行异步操作<br>接受到数据后再dispatch一个action 并且type必须是reducer存在的<br>reducer拦截到action的type和数据返回新的state</p></blockquote></li><li><p>原生</p><blockquote><p>在componentDidMount生命周期函数里 执行异步操作 接受到数据后dispatch一个action<br>此action必须是一个对象包含type和数据<br>reducer拦截到action的type和数据返回新的state</p></blockquote></li></ol></blockquote><h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h3><ol><li><p>安装</p><pre><code>npm install react-redux</code></pre></li><li><p><strong>Provider</strong></p><ul><li>第一个核心API</li></ul><pre><code>// 在index.js中引入import { provider } from 'react-redux';import store from './store';....//provider将自己有的属性提供给内部所有组件//将store引入内部的组件中//注意，jsx语法块用括号包裹const App = ( &lt;Provider store={store}&gt;        &lt;TodoList /&gt;    &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById("root"));</code></pre></li><li><p><strong>connect</strong></p><ul><li>第二个核心API</li></ul><pre><code>//TodoList.js实现连接关系// (1)数据获取的连接const mapStateToProps = (state) =&gt; {    return {        inputValue: state.inputValue,    }}// (2)改变数据方法的连接const mapDsipatchToProps = (dispatch) =&gt; {    return {        handleInputChange(e) {            const action = {        type: "change_input_value",        value: e.target.value,      };      dispatch(action);        }    }}export default connect(mapStateToProps, mapDsipatchToProps)(TodoList);</code></pre><ul><li><p>这样不管是读，还是写都可以直接通过</p><p><code>this.props.inputValue</code></p><p><code>this.props.handleInputChange</code></p><p>来调用</p></li></ul></li></ol><blockquote><p>我们可以发现 ，<todolist>组件就是一个UI组件，connect函数引用了UI组件，加上对store的调用相当于返回了一个容器组件</todolist></p></blockquote><ol start="4"><li><p>优化代码</p><blockquote><ol><li><p>actioncreater.js :</p><pre><code>export const ....一个个函数</code></pre></li><li><p>actionTypes.js :</p><pre><code>export const 宏定义赋值</code></pre></li><li><p>UI组件用函数组件（无状态组件代替）</p></li><li><p>结构化赋值</p><pre><code>const { inputValue, handleInputChange, handleClickBtn, list, handleDeleteItem,} = props;</code></pre></li></ol></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> js_React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React入门项目</title>
      <link href="2020/10/19/react-ru-men-xiang-mu/"/>
      <url>2020/10/19/react-ru-men-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="React入门项目"><a href="#React入门项目" class="headerlink" title="React入门项目"></a>React入门项目</h1><ul><li>本文档为React官网，学习历程，完成第一个React项目–tic-tac-toe</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>这里我们使用官方推荐的Create React App 来完成项目</li></ul><ol><li><p>在项目根目录下打开node （shift + 右键）</p></li><li><p>输入创建新项目指令</p><pre class=" language-js"><code class="language-js">npx create<span class="token operator">-</span>react<span class="token operator">-</span>app my<span class="token operator">-</span>app</code></pre></li><li><p>删掉<code>src/</code>下的所有文件，创建我们需要的<code>index.css</code>,<code>index,js</code></p></li><li><p>最后将下面三行代码写到<code>index.js</code> 文件的顶部</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'./index.css'</span><span class="token punctuation">;</span></code></pre></li></ol><ul><li>运行测试，执行<code>npm start</code>, 会自动弹出浏览器 <code>http://localhost:3000</code>.</li></ul><h2 id="项目概览"><a href="#项目概览" class="headerlink" title="项目概览"></a>项目概览</h2><ul><li>个人理解：React代码就是有很多层级的组件，通过props传递信息，render()函数返回实现一层一层UI界面和交互效果的。</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li>组件：React的独立代码片段，就像封装的函数一样</li></ul><h4 id="函数组件-class组件"><a href="#函数组件-class组件" class="headerlink" title="函数组件/class组件"></a>函数组件/class组件</h4><ul><li>最简单的定义组件的方式就是函数组件</li></ul><pre><code>function Welcome(props) {    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}</code></pre><ul><li>使用类来定义</li></ul><pre><code>class Welcome extends React.Component {    render() {        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;    }}</code></pre><h4 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h4><ol><li><p>React元素：</p><blockquote><p>React元素包含DOM元素和自定义的组件</p><pre><code>const element = &lt;div /&gt;;const element2 = &lt;Welcome name="minyue" /&gt;;</code></pre><ul><li>当React元素为自定义组件时，它会将JSX接受的属性（attributes），子组件（children）转换为单个对象传递给组件，这个对象就是“props”</li><li>组件名称一定要“大写字母开头”，<code>&lt;Welcome /&gt;</code>（小写将被认为是原生DOM）</li></ul></blockquote></li><li><p>渲染</p><blockquote><p>这里要使用到 <code>ReactDOM.render()</code> 函数</p><pre><code>ReactDOM.render(    element,    document.getElementById('root'))</code></pre><ul><li>这个函数就是将React元素element，替换了DOM页面元素实现页面上的渲染</li></ul></blockquote></li></ol><h4 id="提取组件"><a href="#提取组件" class="headerlink" title="提取组件"></a>提取组件</h4><ul><li>这是React非常重要的一种思想方法，将一个复杂的组件，拆分为多层次的组件</li></ul><p>看我们的 <code>井字棋项目</code> 先看静态，大体就是三个组件</p><blockquote><ol><li>Square: 渲染单独的 <code>&lt;button&gt;</code> </li><li>Board: 渲染9个方块</li><li>Game:  渲染含有默认值的键盘</li></ol><p>他们就是在总界面上面，拆分出来的各个组件部分</p></blockquote><h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><ul><li><p>组件间的交互效果</p><blockquote><ol><li>父级到子级的信息传递<ul><li>通过props传递</li></ul></li><li>子级到父级的信息传递<ul><li>通过父级传递给子级的回调函数</li></ul></li><li>同级上的信息传递<ul><li>将信息存在父级，通过父级状态提升</li></ul></li></ol></blockquote></li></ul><h4 id="父–-gt-子"><a href="#父–-gt-子" class="headerlink" title="父–>子"></a>父–&gt;子</h4><ul><li>尝试将数据从Board组件传递到Square组件中（也就是将Board9个方格的数据，通过props传递到Square组件显示出来</li></ul><pre><code>// 改写Board组件的renderSquare方法，传递value到Square中class Board extends React.Component {    renderSquare(i) {        return &lt;Square value={i} /&gt;    }} //修改Square组件中的render函数接受传来的参数修改界面的值class Square extends React.Component {    render() {        return (            &lt;button className="square"&gt;                {this.props.value}            &lt;/button&gt;        );    }}</code></pre><ul><li>渲染后可以看到每个方格都有一个数组</li></ul><img src="/2020/10/19/react-ru-men-xiang-mu/%E4%BC%A0%E5%8F%82%E5%89%8D.png" class="" title="传参前"><img src="/2020/10/19/react-ru-men-xiang-mu/%E4%BC%A0%E5%8F%82%E5%90%8E.png" class="" title="传参后"><ul><li>React 应用中，数据通过 props 的传递，从父组件流向子组件。</li></ul><h4 id="平行通信"><a href="#平行通信" class="headerlink" title="平行通信"></a>平行通信</h4><ul><li><p>我们需要知道9个Square组件的状态，来判断游戏的胜负</p></li><li><p>这里就用到了多个组件相互通信—-状态提升</p><blockquote><p>状态提升：<strong>把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中</strong></p></blockquote></li></ul><pre><code>// 这里我们在Board组件初始化时设置9个空值数组class Board extends React.Component {    constructor(props) {        super(props);        this.state = {            squares: Array(9).fill(null),        };    }}handleClick(i) {    const squares = this.state.squares.slice();    squares[i] = 'X';    this.setState({squares: squares});}renderSquare(i) {    return (&lt;Square                value={this.state.squares[i]}                onclick={() =&gt; this.handleClick(i)}            /&gt;    );}render() {       //界面布局}</code></pre><ul><li><p>上面父类向子类传递了一个回调函数<code>handleClick()</code>来返回信息</p></li><li><p><strong>注意：</strong><code>handleClick()</code>,不要改变原始数据，创建副本！！！</p><blockquote><p>好处：</p><ol><li>撤回，恢复功能很需要</li><li>不可变数据，容易跟踪变化</li><li>react中，不可变性帮助我们创建 <a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html#examples">pure components</a>。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染。</li></ol></blockquote></li></ul><p>当数据提升到父类之后，子类就不需要构造函数（state）了，数据完全由<code>props</code>,<code>回调函数</code>这个双向通道进行传输</p><pre><code>class Square extends React.Component {    render() {        return (            &lt;button                className="square"                onClick={() =&gt; this.props.onClick()}                &gt;                {this.props.value}            &lt;/button&gt;         );    }}// 不包含state时 使用函数组件更加简单// 函数组件中 箭头函数简写// onClick={() =&gt; this.props.onClick()} 改成了更短的 onClick={props.onClick}function Square(props) {    return (&lt;button className="square" onClick={props.onClick}&gt;            {props.value}            &lt;/button&gt;    );}</code></pre><h4 id="子–-gt-父"><a href="#子–-gt-父" class="headerlink" title="子–>父"></a>子–&gt;父</h4><ul><li>上面的回调函数</li></ul><h2 id="项目完善"><a href="#项目完善" class="headerlink" title="项目完善"></a>项目完善</h2><ul><li>到目前为止，我们的井字棋程序，超需要加入<code>轮流落子</code>，<code>历史记录回溯</code></li></ul><h4 id="轮流落子"><a href="#轮流落子" class="headerlink" title="轮流落子"></a>轮流落子</h4><ul><li>添加<code>xIsNext: true</code>属性</li></ul><h4 id="判断胜出者"><a href="#判断胜出者" class="headerlink" title="判断胜出者"></a>判断胜出者</h4><ul><li><p>添加<code>status</code>属性，<code>calculateWinner()</code></p></li><li><p>功能分析：当点击<code>Square</code>时，触发回调函数<code>handleClick(i)</code></p><blockquote><ol><li>是否有玩家胜出？</li><li>是否当前空格已经填过？</li><li>其他情况正常翻转改变！</li></ol><pre><code>// 在初始化state中添加 xIsNext 属性，true代表X，flase代表O handleClick(i) {    const squares = this.state.squares.slice();    if(calculateWinner(squares) || squares[i]) {        return;    }    squares[i] = this.state.xIsNext ? 'X' : 'O';    this.setState({        squares: squares,        xIsNext: !this.xIsNext,    });}render() {    const winner = calculateWinner(this.state.squares);    let status;    if (winner) {        status = 'winner:' + winner;    } else {        status = 'Next Player:' + (this.state.xIsNext ? 'X' : 'O');    }}return (    const status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');    return (      &lt;div&gt;        &lt;div className="status"&gt;{status}&lt;/div&gt;        &lt;div className="board-row"&gt;          {this.renderSquare(0)}          {this.renderSquare(1)}          {this.renderSquare(2)}        &lt;/div&gt;        &lt;div className="board-row"&gt;          {this.renderSquare(3)}          {this.renderSquare(4)}          {this.renderSquare(5)}        &lt;/div&gt;        &lt;div className="board-row"&gt;          {this.renderSquare(6)}          {this.renderSquare(7)}          {this.renderSquare(8)}        &lt;/div&gt;      &lt;/div&gt;    );  });</code></pre><ul><li>将计算函数放在组件外面</li></ul><pre><code>function calculateWinner(squares) {  const lines = [    [0, 1, 2],    [3, 4, 5],    [6, 7, 8],    [0, 3, 6],    [1, 4, 7],    [2, 5, 8],    [0, 4, 8],    [2, 4, 6],  ];  for (let i = 0; i &lt; lines.length; i++) {    const [a, b, c] = lines[i];    if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) {      return squares[a];    }  }  return null;}</code></pre></blockquote></li></ul><h4 id="事件旅行"><a href="#事件旅行" class="headerlink" title="事件旅行"></a>事件旅行</h4><ul><li>不可变对象的优势就体现出来了，我们将历史的<code>squares</code>数组保存在<code>history</code>数组中</li></ul><pre><code>history = [  // 第一步之前  {    squares: [      null, null, null,      null, null, null,      null, null, null,    ]  },  // 第一步之后  {    squares: [      null, null, null,      null, 'X', null,      null, null, null,    ]  },  // 第二步之后  {    squares: [      null, null, null,      null, 'X', null,      null, null, 'O',    ]  },  // ...]</code></pre><ul><li><p>考虑，我们应该把<code>history</code>放在哪个组件中</p><p>——-保存在顶层组件Game中</p></li></ul><h5 id="再次提升状态！！！"><a href="#再次提升状态！！！" class="headerlink" title="再次提升状态！！！"></a><strong>再次提升状态！！！</strong></h5><blockquote><p>将数据提升到Game中，删除Board 组件中的 state，Game 组件就拥有了对 Board 组件数据的完全控制权（当前和过去）</p></blockquote><ul><li>Game组件初始化</li></ul><pre><code>class Game extends React.Component {    constructor(props) {        super(props);        this.state = {            history: [{                squares: Array(9).fill(null),            }],            xIsNext: true,        };    }    render() {        return (            &lt;div className="game"&gt;                &lt;div className="game-board"&gt;                    &lt;Board /&gt;                &lt;/div&gt;                &lt;div className="game-info"&gt;                    &lt;div&gt;{/* status */}&lt;/div&gt;                    &lt;ol&gt;{/* TODO */}&lt;/ol&gt;                &lt;/div&gt;            &lt;/div&gt;        );    }}</code></pre><ul><li><p>修改<code>board</code>组件</p><blockquote><ol><li><p>删除构造函数constructor()</p></li><li><p>执行函数handleClick()提升到Game组件</p><blockquote><p><code>this.handleClick(i)</code> 替换为 <code>this.props.onClick(i)</code></p></blockquote></li><li><p>将所有的<code>state</code>，换成<code>props</code></p></li></ol></blockquote></li></ul><pre><code>renderSquare(i) {    return (        &lt;Square            value={this.props.squares[i]}            onClick={() =&gt; this.props.onClick(i)}            /&gt;    );}</code></pre><ul><li>修改<code>handleClick(i)</code></li></ul><pre><code>// 需要把新的历史记录拼接到 history 上// 使用concat()完成数组拼接  不改变原数组！！handleClick(i) {    const history = this.state.history;    const current = history[history.length - 1];    const squares = current.squares.slice();    if (calculateWinner(squares) || squares[i]) {      return;    }    squares[i] = this.state.xIsNext ? 'X' : 'O';    this.setState({        history: history.concat([{            squares: squares,        }]),        xIsNext: !this.state.xIsNext,    })}</code></pre><ul><li>render函数更改</li></ul><pre><code>// Board组件中的render 渲染状态的提升到Game中render() {    const history = this.state.history;    const current = history[history.length - 1];    const winner = calculateWinner(current.squares);    let status;    if (winner) {        status = 'Winner: ' + winner;    } else {        status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');    }    return (        &lt;div className="game"&gt;            &lt;div className="game-board"&gt;                &lt;Board                    squares={current.squares}                    onClick={(i) =&gt; this.handleClick(i)}                    /&gt;            &lt;/div&gt;            &lt;div className="game-info"&gt;                &lt;div&gt;{status}&lt;/div&gt;                &lt;ol&gt;{/* TODO */}&lt;/ol&gt;            &lt;/div&gt;        &lt;/div&gt;    );}</code></pre><h5 id="展示历史记录"><a href="#展示历史记录" class="headerlink" title="展示历史记录"></a><strong>展示历史记录</strong></h5><ul><li><p>使用<code>map</code>方法，把历史记录映射为代表按钮的React元素</p><blockquote><p>Game组件，<code>render</code>方法中调用<code>history</code> 的 <code>map方法</code></p></blockquote><pre><code>// map方法返回moves（按钮数组），其中参数(step,move-&gt; 当前元素，编号)render() {    const history = this.state.history;    const current = history[history.length - 1];    const winner = calculateWinner(current.squares);    const moves = history.map((step, move) =&gt; {        const desc = move ?              'Go to move #' + move :        'Go to game start';        return (            &lt;li&gt;                &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt;            &lt;/li&gt;        );    });    let status;    if (winner) {        status = 'Winner: ' + winner;    } else {        status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');    }    return (        &lt;div className="game"&gt;            &lt;div className="game-board"&gt;                &lt;Board                    squares={current.squares}                    onClick={(i) =&gt; this.handleClick(i)}                    /&gt;            &lt;/div&gt;            &lt;div className="game-info"&gt;                &lt;div&gt;{status}&lt;/div&gt;                &lt;ol&gt;{moves}&lt;/ol&gt;            &lt;/div&gt;        &lt;/div&gt;    );}</code></pre></li><li><p>使用map时，值得注意的<code>key</code></p><blockquote><p>列表需要一个 key 属性，区分不同的列表项</p><ul><li><p><code>key</code> 是 React 中一个特殊的保留属性（还有一个是 <code>ref</code>，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 <code>key</code> 属性，然后把 key 直接存储在返回的元素上。虽然 <code>key</code> 看起来好像是 <code>props</code> 中的一个，但是你不能通过 <code>this.props.key</code> 来获取 <code>key</code>。React 会通过 <code>key</code> 来自动判断哪些组件需要更新。组件是不能访问到它的 <code>key</code> 的。</p></li><li><p><strong>强烈推荐，每次只要你构建动态列表的时候，都要指定一个合适的 key</strong></p></li></ul></blockquote><pre><code>//历史步骤不需要重新排序、新增、删除，所以使用步骤的索引作为 key 是安全的const moves = history.map((step, move) =&gt; {    const desc = move ?          'Go to move #' + move :    'Go to game start';    return (        &lt;li key={move}&gt;            &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt;        &lt;/li&gt;    );});</code></pre></li><li><p>设置 <code>jumpTo</code> 方法</p><blockquote><ol><li>Game 的构造函数 <code>constructor</code> 中向初始 state 中添加 <code>stepNumber: 0</code><ul><li>表示当前查看哪一步历史记录，默认初始0</li></ul></li><li>当状态 <code>stepNumber</code> 是偶数时，我们还要把 <code>xIsNext</code> 设为 true：</li></ol></blockquote></li></ul><pre><code>jumpTo(step) {    this.setState({        stepNumber: step,        xIsNext: (step % 2) === 0,    });}</code></pre><ul><li><p><code>handleClick</code> 方法</p><blockquote><ol><li><p>读取 <code>this.state.history</code> 换成了读取 <code>this.state.history.slice(0, this.state.stepNumber + 1)</code></p><blockquote><p>保证回溯时，更新未来的数据</p></blockquote></li><li><p><code>this.setState</code> 并传入参数 <code>stepNumber: history.length</code>，以更新 <code>stepNumber</code>。</p></li></ol></blockquote><pre><code>handleClick(i) {    const history = this.state.history.slice(0, this.state.stepNumber + 1);    const current = history[history.length - 1];    const squares = current.squares.slice();    if (calculateWinner(squares) || squares[i]) {        return;    }    squares[i] = this.state.xIsNext ? 'X' : 'O';    this.setState({        history: history.concat([{            squares: squares        }]),        stepNumber: history.length,        xIsNext: !this.state.xIsNext,    });}</code></pre></li><li><p>最后修改render方法</p></li></ul><pre><code>render() {    const history = this.state.history;    const current = history[this.state.stepNumber];    const winner = calculateWinner(current.squares);    // 其他部分没有改变</code></pre><h2 id="项目拓展"><a href="#项目拓展" class="headerlink" title="项目拓展"></a>项目拓展</h2><ol><li><p>在游戏记录列表中显示每一步棋的坐标（列号，行号）</p><blockquote><ul><li><p>这里玩的思路就是对history数组调用map函数，每次改变的时候循环遍历渲染一遍列表按钮。</p></li><li><p>将9个位置的坐标，用数组的形式存储起来（比较像二维数组）</p></li><li><p>在game组件中新增一个clickNum数组存储每一步的按钮值，也就是利用这个按钮值对应每一个坐标数组的索引</p></li><li><p>最后将数组转换为坐标形式展示出来</p></li></ul></blockquote></li><li><p>历史记录中加粗显示当前选择的项目</p><blockquote><p>这个只需要一个判断：</p><ul><li>在渲染坐标后，当渲染到当前按钮时，就添加一个css类样式就行</li></ul></blockquote></li><li><p>使用两个循环来渲染格子，而不是代码写死</p><blockquote><p>两层for循环：</p><ul><li>外层行</li><li>内层列</li><li>每次将内层渲染的三个squares数组push到预定义的outerDiv数组中</li><li>注意，因为是遍历动态添加的列表，所以添加的button都要加key值</li></ul></blockquote></li><li><p>添加一个可以升序或者降序的按钮</p><blockquote><p>简单的设定一个state变量desc，构造一个点击事件就行了</p><ul><li>只是倒序列表需要加属性<code>reversed</code></li></ul></blockquote></li><li><p>当有人获胜时，高亮显示3点一线</p><blockquote><ul><li>在state中设定了两个属性winner，winNum分别存放获胜者是谁，获胜者的棋子位置</li></ul><p>在square组件中设定，获取对应winNum（存储着获胜者的棋子位置），对对应位置的按钮添加css类样式</p></blockquote></li><li><p>当无人获胜，显示平局信息</p><blockquote><p>声明一个变量，由calculateWinner函数返回的winResult做判断，如果winResult非null则输出获胜者，如果null并且步数小于8输出下一步的棋手，如果等于9输出平局</p></blockquote></li></ol><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><img src="/2020/10/19/react-ru-men-xiang-mu/%E5%88%9D%E5%A7%8B.png" class="" title="初始"> <img src="/2020/10/19/react-ru-men-xiang-mu/X%E8%83%9C%E5%88%A9.png" class="" title="X胜利"><img src="/2020/10/19/react-ru-men-xiang-mu/%E5%80%92%E5%BA%8F.png" class="" title="倒序"> <img src="/2020/10/19/react-ru-men-xiang-mu/%E5%B9%B3%E5%B1%80.png" class="" title="平局"><p><strong>完整代码：</strong><a href="https://github.com/minyue-hcm/my_work/tree/master/tic_tac_toe">github链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象属性配置</title>
      <link href="2020/10/14/dui-xiang-shu-xing-pei-zhi/"/>
      <url>2020/10/14/dui-xiang-shu-xing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><ul><li><p>我们知道js对象中可以存储属性和方法，对于存储的属性不只是”键值对”，对象属性实际上还有更加灵活强大的东西</p></li><li><p>下面我们来看一下对象属性到底还有声明nb功能呢？</p></li></ul><h2 id="属性的分类"><a href="#属性的分类" class="headerlink" title="属性的分类"></a>属性的分类</h2><ul><li>对象属性有两种类别</li></ul><ol><li><strong>数据属性</strong>：键值对形式</li><li><strong>访问器属性</strong>：用于获取和设置值的函数</li></ol><h2 id="属性标志和属性描述符"><a href="#属性标志和属性描述符" class="headerlink" title="属性标志和属性描述符"></a>属性标志和属性描述符</h2><ul><li><p>对象属性，除了**<code>value</code>** 外，还有三个特殊的特性（attributes）</p><blockquote><ul><li><strong><code>writable</code></strong> — 如果为 <code>true</code>，则值可以被修改，否则它是只可读的。</li><li><strong><code>enumerable</code></strong> — 如果为 <code>true</code>，则会被在循环中列出，否则不会被列出。</li><li><strong><code>configurable</code></strong> — 如果为 <code>true</code>，则此特性可以被删除，这些属性也可以被修改，否则不可以。</li></ul></blockquote></li><li><p>我们使用“常用的方式”创建的属性都是<code>true</code></p></li></ul><h4 id="如何获取这些标识-特性？"><a href="#如何获取这些标识-特性？" class="headerlink" title="如何获取这些标识/特性？"></a>如何获取这些标识/特性？</h4><ul><li><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a> 方法允许查询有关属性的 <strong>完整</strong> 信息。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);</span><span class="token comment" spellcheck="true">//obj : 需要获取信息的对象</span><span class="token comment" spellcheck="true">//propertyName: 属性的名称</span><span class="token comment" spellcheck="true">//返回值: 所谓的“属性描述符对象“ 包含值和所有标志</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 属性描述符：{  "value": "John",  "writable": true,  "enumerable": true,  "configurable": true}*/</span></code></pre><h4 id="如何修改这些标志呢？"><a href="#如何修改这些标志呢？" class="headerlink" title="如何修改这些标志呢？"></a>如何修改这些标志呢？</h4><ul><li>可以使用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a></li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Object.defineProperty(obj, propertyName, descriptor)</span><span class="token comment" spellcheck="true">// obj, propertyName: 对象及其属性</span><span class="token comment" spellcheck="true">// descriptor: 应用的属性描述符"对象"</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token string">"John"</span>        <span class="token comment" spellcheck="true">//没有对应属性就新建一个对应属性</span>  <span class="token comment" spellcheck="true">//其他属性不写默认 false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*{  "value": "John",  "writable": false,  "enumerable": false,  "configurable": false} */</span></code></pre><ul><li>补充：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify()</a></li></ul><h4 id="属性描述符的功能"><a href="#属性描述符的功能" class="headerlink" title="属性描述符的功能"></a>属性描述符的功能</h4><h5 id="1-只读writable"><a href="#1-只读writable" class="headerlink" title="1.只读writable"></a>1.只读writable</h5><ul><li>将<code>writable</code> 谁行标志设置为<code>false</code> ，就将对应属性设置为只读属性</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"minyue"</span><span class="token punctuation">}</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//minyue</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"hcm"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在严格模式下就会出错，非严格模式忽略</span></code></pre><ul><li>对于一个新属性，我们需要明确列出那些<code>true</code>,未列出的默认<code>false</code></li><li>对于一个常规定义的属性，默认都是<code>true</code>,改什么就变什么</li></ul><h5 id="2-不可枚举enumerable"><a href="#2-不可枚举enumerable" class="headerlink" title="2.不可枚举enumerable"></a>2.不可枚举enumerable</h5><ul><li><p>对象的枚举，我们通过<code>for  in</code>语句，是否能枚举对应的<strong>键</strong></p><blockquote><p>通常情况下，对象内置的<code>toString</code> 是不可枚举的，当我们在对象中，创建的属性或者方法，也不想被枚举出就可以设置<code>enumerable:false</code></p></blockquote></li><li><p>同样不可枚举的属性也会被<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"> object.keys(obj) </a> (返回键的数组）</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"minyue"</span><span class="token punctuation">,</span>    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">"toString"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//name</span><span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//name</span></code></pre><h5 id="3-不可配置"><a href="#3-不可配置" class="headerlink" title="3.不可配置"></a>3.不可配置</h5><ul><li>不可配置<code>configurable:false</code> 有时会预设在内建对象和属性中</li><li>不可配置的属性思想：防止更改属性标志或删除属性标志</li><li>特殊点：不可配置的可写属性是可以修改属性的值的！！！</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//例如：Math.PI 只读，不可枚举，不可配置</span><span class="token keyword">let</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> <span class="token string">'PI'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*{  "value": 3.141592653589793,  "writable": false,  "enumerable": false,  "configurable": false}*/</span>Math<span class="token punctuation">.</span>PI <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error</span></code></pre><h4 id="批量获取-修改属性标志符"><a href="#批量获取-修改属性标志符" class="headerlink" title="批量获取/修改属性标志符"></a>批量获取/修改属性标志符</h4><ul><li><h5 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h5></li><li><h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h5></li></ul><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span> writable<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  surname<span class="token punctuation">:</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span> writable<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//克隆对象:首选方法，不只是值，还有属性描述符等</span><span class="token keyword">let</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>扩展：学到这里，我们知道，属性描述符都是单一属性级别上的工作，要想限制访问整个对象，<a href="https://zh.javascript.info/property-descriptors#she-ding-yi-ge-quan-ju-de-mi-feng-dui-xiang">参考</a></p><h2 id="属性的getter和setter"><a href="#属性的getter和setter" class="headerlink" title="属性的getter和setter"></a>属性的getter和setter</h2><h4 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h4><ul><li>看完<strong>数据属性</strong>，下面我们来看一下<strong>访问器属性</strong></li><li>访问器属性：本质上是用于获取和设置值的函数</li></ul><p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 <code>get</code> 和 <code>set</code> 表示：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>  surname<span class="token punctuation">:</span> <span class="token string">"Smith"</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 当读取 obj.propName 时，getter 起作用</span>      <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 当执行 obj.propName = value 操作时，setter 起作用</span>      <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">"Alice Cooper"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用setter</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>fullname<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// Alice Cooper</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>surname<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// Cooper</span></code></pre><h4 id="访问器描述符"><a href="#访问器描述符" class="headerlink" title="访问器描述符"></a>访问器描述符</h4><ul><li><strong><code>get</code></strong> —— 一个没有参数的函数，在读取属性时工作，</li><li><strong><code>set</code></strong> —— 带有一个参数的函数，当属性被设置时调用，</li><li><strong><code>enumerable</code></strong> —— 与数据属性的相同，</li><li><strong><code>configurable</code></strong> —— 与数据属性的相同。</li></ul><p>使用 <code>defineProperty</code> 创建一个 <code>fullName</code> 访问器</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>  surname<span class="token punctuation">:</span> <span class="token string">"Smith"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> <span class="token string">'fullName'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// John Smith</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> user<span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// name, surname</span></code></pre><h4 id="巧妙的getter和setter"><a href="#巧妙的getter和setter" class="headerlink" title="巧妙的getter和setter"></a>巧妙的getter和setter</h4><ul><li>Getter/setter 可以用作“真实”属性值的包装器，以便对它们进行更多的控制。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//例如：当我们需要输入用户名不能太短时</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Name is too short, need at least 4 characters"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Pete"</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Pete</span>user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Name 太短了……</span></code></pre><ul><li>访问器属性本身就是两个函数，没有值，存值一般会有一个内部数据属性存值！！（例如这里的<code>_name</code>)</li></ul><h4 id="访问器属性实例"><a href="#访问器属性实例" class="headerlink" title="访问器属性实例"></a>访问器属性实例</h4><ul><li>访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 对于年龄这样的变化数据，我们希望存储birthday而不是age</span><span class="token comment" spellcheck="true">// 这里我们就可以使用访问器属性，动态获取修改对象的age属性</span><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> birthday<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 年龄是根据当前日期和生日计算得出的</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> todayYear <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> todayYear <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>birthday<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> john <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> john<span class="token punctuation">.</span>birthday <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Mon Nov 29 1999 00:00:00 GMT+0800 (中国标准时间)</span><span class="token function">alert</span><span class="token punctuation">(</span> john<span class="token punctuation">.</span>age <span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 21</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
            <tag> js_对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise回调</title>
      <link href="2020/10/13/promise-hui-diao/"/>
      <url>2020/10/13/promise-hui-diao/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise回调"><a href="#Promise回调" class="headerlink" title="Promise回调"></a>Promise回调</h1><h2 id="引入promise"><a href="#引入promise" class="headerlink" title="引入promise"></a>引入promise</h2><ul><li><p>为什么js要加入回调这一概念？  让我们来看下面的示例</p></li><li><p>异步编程</p></li></ul><p>下面一个异步行为：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//使用loadScript(src)给脚本加载给定的src</span><span class="token keyword">function</span> <span class="token function">loadScript</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>    document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">'/my/script.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//但是我们会发现：</span><span class="token comment" spellcheck="true">// loadScript 下面的代码</span><span class="token comment" spellcheck="true">// 不会等到脚本加载完成才执行</span></code></pre><ul><li>可以看出，我们需要一个回调信息，告诉我们浏览器何时完成了加载，之后我们才能使用新加载的函数和属性</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//于是我们将函数加入回调函数参数</span><span class="token comment" spellcheck="true">//callback函数就实现了，当脚本文件加载完毕立即执行回调函数内容</span><span class="token keyword">function</span> <span class="token function">loadScript</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  script<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>  script<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> script<span class="token punctuation">)</span><span class="token punctuation">;</span>  script<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Script load error for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>src<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">'/my/script.js'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> script<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理 error</span>      <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 脚本加载成功</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>于此，我们又发现了新的问题，如果有多个嵌套的引入函数时，我们就要把代码写的像“厄运金字塔”一样，很容易失控！</li></ul><img src="/2020/10/13/promise-hui-diao/%E5%8E%84%E8%BF%90%E9%87%91%E5%AD%97%E5%A1%94.png" class="" title="厄运金字塔"><ul><li>进一步，我们想通过多个函数分开写法，减少嵌套,但这种方式代码支离破碎，读起来跳来跳去，多个函数命名也是问题，于是我们探索更好的方式，最好的方法之一就是 “promise”</li></ul><pre class=" language-js"><code class="language-js"><span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">'1.js'</span><span class="token punctuation">,</span> step1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">step1</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> script<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">'2.js'</span><span class="token punctuation">,</span> step2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">step2</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> script<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">'3.js'</span><span class="token punctuation">,</span> step3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">step3</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> script<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...加载完所有脚本后继续 (*)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li><p>这里我们做一个类比</p><blockquote><p>“生产者代码”做一些事，并且需要一些时间，如：通过网络加载数据的代码，像一位歌手</p><p>“消费者代码”想在”生产者代码”完成工作第一时间得到其工作成果，像粉丝</p></blockquote></li><li><p>promise就是将两者连接在一起的特殊JS对象</p><blockquote><p>前者：传递给 <code>new Promise</code>的函数<strong>executor</strong>，对象创建时自动执行</p><p>后者：将接收结果或 error。可以通过使用 <code>.then</code>、<code>.catch</code> 和 <code>.finally</code> 方法为消费函数进行注册。</p></blockquote></li></ul><h3 id="构造器语法"><a href="#构造器语法" class="headerlink" title="构造器语法"></a>构造器语法</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resovle<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// executor (生产者代码，“歌手”)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li><p>传递给 <code>new Promise</code>的函数是<strong>executor</strong>，对象创建时自动执行—就是歌手</p><blockquote><p>resolve 和 reject 是Javascript自身提供的的回调</p><ul><li><code>resolve(value)</code> — 如果任务成功完成并带有结果 <code>value</code>。</li><li><code>reject(error)</code> — 如果出现了 error，<code>error</code> 即为 error 对象。</li></ul></blockquote></li><li><p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p><blockquote><ul><li><code>state</code> — 最初是 <code>"pending"</code>，然后在 <code>resolve</code> 被调用时变为 <code>"fulfilled"</code>，或者在 <code>reject</code> 被调用时变为 <code>"rejected"</code>。</li><li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul></blockquote></li></ul><img src="/2020/10/13/promise-hui-diao/promise%E5%B1%9E%E6%80%A7.png" class="" title="promise属性"><ul><li><p>看两个实例</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// (1) 成功完成</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当 promise 被构造完成时，自动执行此函数</span>  <span class="token comment" spellcheck="true">// 1 秒后发出工作已经被完成的信号，并带有结果 "done"</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><img src="/2020/10/13/promise-hui-diao/sucess%E6%A1%88%E4%BE%8B.png" class="" title="sucess案例"><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// (2) error案例</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 1 秒后发出工作已经被完成的信号，并带有 error</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="/2020/10/13/promise-hui-diao/error%E6%A1%88%E4%BE%8B.png" class="" title="error案例"><ul><li><p>注意：executor 只能调用一个<code>resolve</code> 或一个 <code>reject</code></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 宗旨:一个被 executor 完成的工作只能有一个结果或一个 error。</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"…"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 被忽略</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"…"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 被忽略</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="消费者：then，catch，finally"><a href="#消费者：then，catch，finally" class="headerlink" title="消费者：then，catch，finally"></a>消费者：then，catch，finally</h3><ul><li><code>state</code> <strong>和</strong> <code>result</code> <strong>都是内部的</strong>,不能直接访问他们，但我们可以对他们使用<code>.then</code>/<code>.catch</code>/<code>.finally</code> 方法</li></ul><h5 id="then"><a href="#then" class="headerlink" title="then"></a><strong>then</strong></h5><pre class=" language-js"><code class="language-js">promise<span class="token punctuation">.</span>then <span class="token punctuation">(</span>    <span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//handle a successful result</span>    <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token template-string"><span class="token string">``</span></span><span class="token comment" spellcheck="true">//handle an error</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>第一个参数是一个函数，在<code>promise resovled</code> 后运行并接受结果</li><li>第二个参数也是一个函数，在<code>promise rejected</code>后运行并接受error</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resovle<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"done!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//resolve运行，1s后执行第一个函数</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    result <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//done!</span>    error <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//Error:Whoops!</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//reject情况, 执行上面第二个函数</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'whoops!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>如果只关心完成成功的结果！</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"done~"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//1s后显示  done~</span></code></pre><h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a><strong>catch</strong></h5><ul><li>如果我们只对error感兴趣</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 使用null作为第一个参数</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// .catch(f) 和 .then(null, f) 一样</span>promise<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>.catch(f)</code> 调用是 <code>.then(null, f)</code> 的完全的模拟，它只是一个简写形式</li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h5><ul><li>像常规的 <code>try {...} catch {...}</code> 中的 <code>finally</code> 子句一样，promise 中也有 <code>finally</code>。</li><li><code>.finally(f)</code> 调用与 <code>.then(f, f)</code> 类似，在某种意义上，<code>f</code> 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject。</li><li><code>finally</code> 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）。</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 做一些需要时间的事儿，然后调用 resolve/reject */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 在 promise 被 settled 时运行，无论成功与否</span><span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> stop loading indicator<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> show result<span class="token punctuation">,</span> err <span class="token operator">=</span><span class="token operator">></span> show error<span class="token punctuation">)</span></code></pre><ol><li><code>finally</code> 处理程序（handler）没有参数。在 <code>finally</code> 中，我们不知道 promise 是否成功。</li><li><code>finally</code> 处理程序将结果和 error 传递给下一个处理程序。</li><li><code>.finally(f)</code> 是比 <code>.then(f, f)</code> 更为方便的语法</li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h5><ul><li><p>在 settled 的 promise 上，**<code>then</code> <strong>会立即运行</strong></p></li><li><p>promise 为 pending 状态，<code>.then/catch/finally</code> 处理程序（handler）将等待它。否则，如果 promise 已经是 settled 状态，它们就会立即执行，这也是Promise的优点</p></li></ul><h5 id="示例：loadScript"><a href="#示例：loadScript" class="headerlink" title="示例：loadScript"></a>示例：loadScript</h5><ul><li>前面我们提到，用于加载脚本的 <code>loadScript</code> 函数。</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">loadScript</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  script<span class="token punctuation">.</span>src <span class="token operator">=</span> src<span class="token punctuation">;</span>  script<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> script<span class="token punctuation">)</span><span class="token punctuation">;</span>  script<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Script load error for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>src<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>下面用promise重写:</li></ul><p>新函数 <code>loadScript</code> 将不需要回调。取而代之的是，它将创建并返回一个在加载完成时解析（resolve）的 promise 对象。外部代码可以使用 <code>.then</code> 向其添加处理程序（订阅函数）</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">loadScript</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Script load error for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>src<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 用法</span><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token function">loadscript</span><span class="token punctuation">(</span><span class="token string">"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    script <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>script<span class="token punctuation">.</span>src<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> is loaded`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    error <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Error </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token punctuation">.</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>script <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Another handler...'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th>Promise</th><th>Callbacks</th></tr></thead><tbody><tr><td>Promises 允许我们按照自然顺序进行编码。首先，我们运行 <code>loadScript</code> 和 <code>.then</code> 来处理结果。</td><td>在调用 <code>loadScript(script, callback)</code> 时，在我们处理的地方（disposal）必须有一个 <code>callback</code> 函数。换句话说，在调用 <code>loadScript</code> <strong>之前</strong>，我们必须知道如何处理结果。</td></tr><tr><td>我们可以根据需要，在 promise 上多次调用 <code>.then</code></td><td>只能有一个回调。</td></tr></tbody></table><ul><li>promise 为我们提供了更好的代码流和灵活性。</li></ul><h2 id="Promise链"><a href="#Promise链" class="headerlink" title="Promise链"></a>Promise链</h2><ul><li>异步任务一个接着一个，怎样写出更好的代码呢？</li></ul><p><strong>简单看一下Promise链：</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (*)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (**)</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (***)</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>将 result 通过 <code>.then</code> 处理程序（handler）链进行传递。</li></ul><img src="/2020/10/13/promise-hui-diao/Promise%E9%93%BE.png" class="" title="Promise链"><ul><li><code>promise.then</code> 的调用会返回了一个 promise，所以我们可以在其之上调用下一个 <code>.then</code>。</li><li>当处理程序（handler）返回一个值时，它将成为该 promise 的 result，所以将使用它调用下一个 <code>.then</code>。</li></ul><p><strong>错误点</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>这里所做的只是一个 promise 的几个处理程序（handler）。它们不会相互传递 result；相反，它们之间彼此独立运行处理任务</li></ul><img src="/2020/10/13/promise-hui-diao/%E9%94%99%E8%AF%AF%E7%A4%BA%E8%8C%83.png" class="" title="错误示范"><h3 id="返回promise"><a href="#返回promise" class="headerlink" title="返回promise"></a>返回promise</h3><ul><li><p><code>.then(handler)</code> 中所使用的处理程序（handler）可以创建并返回一个 promise</p></li><li><p>其他的处理程序（handler）将等待它 settled 后再获得其结果（result）</p></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (*)</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span>result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (**)</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span>result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>与前面的示例相同：1 → 2 → 4，但是现在在每次 <code>alert</code> 调用之间会有 1 秒钟的延迟。</li><li>返回 promise 使我们能够构建异步行为链</li></ul><h3 id="示例：loadScript-1"><a href="#示例：loadScript-1" class="headerlink" title="示例：loadScript"></a>示例：loadScript</h3><ul><li>与前面的loadScript函数结合</li></ul><pre class=" language-js"><code class="language-js"><span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">"/article/promise-chaining/one.js"</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>script <span class="token operator">=</span><span class="token operator">></span> <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">"/article/promise-chaining/two.js"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>script <span class="token operator">=</span><span class="token operator">></span> <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">"/article/promise-chaining/three.js"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>script <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 脚本加载完成，我们可以在这儿使用脚本中声明的函数</span>    <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">three</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>每个 <code>loadScript</code> 调用都返回一个 promise，并且在它 resolve 时下一个 <code>.then</code> 开始运行。然后，它启动下一个脚本的加载。所以，脚本是一个接一个地加载的。</p></li><li><p>我们可以向每个 <code>loadScript</code> 直接添加 <code>.then</code>，但是那样是向右增长的，内层可以访问外层的变量有风险！！</p></li></ul><blockquote><p>Thenables</p><ul><li>确切的说，处理程序返回的不完全是一个promise，而是一个被称为“thenable”对象，（一个具有<code>.then</code> 方法的任意对象，我们当做promise对象看待</li><li>设计源于：因为实现了<code>.then</code>方法，第三方库可以实现自己的“promise”兼容对象，他们可以具有扩展的方法集，也和原生的promise兼容</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 实例</span><span class="token keyword">class</span> <span class="token class-name">Thenable</span> <span class="token punctuation">{</span> <span class="token function">constructor</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">alert</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// function() { native code }</span>   <span class="token comment" spellcheck="true">// 1 秒后使用 this.num*2 进行 resolve</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thenable</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (*)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1000ms 后显示 2</span></code></pre><ul><li><code>(*)</code> 行中由 <code>.then</code> 处理程序（handler）返回的对象：如果它具有名为 <code>then</code> 的可调用方法，那么它将调用该方法并提供原生的函数 <code>resolve</code> 和 <code>reject</code> 作为参数（类似于 executor）</li><li><code>resolve(2)</code> 在 1 秒后被调用，result 会被进一步沿着链向下传递。</li><li>这个特性允许我们将自定义的对象与 promise 链集成在一起，而不必继承自 <code>Promise</code>。</li></ul></blockquote><h3 id="更复杂的示例：fetch"><a href="#更复杂的示例：fetch" class="headerlink" title="更复杂的示例：fetch"></a>更复杂的示例：fetch</h3><ul><li>前端编程中，promise通常用于网络请求</li></ul><ol><li><p>使用 <a href="https://zh.javascript.info/fetch">fetch</a> 方法从远程服务器加载用户信息</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><ol><li><p>向<code>url</code> 发出网络请求，并返回一个promise。</p></li><li><p>当远程服务器返回 header（是在 <strong>全部响应加载完成前</strong>）时，该 promise 使用一个 <code>response</code> 对象来进行 resolve。</p></li><li><p>为了读取完整的响应，我们应该调用 <code>response.text()</code> 方法：当全部文字（full text）内容从远程服务器下载完成后，它会返回一个 promise，该 promise 以刚刚下载完成的这个文本作为 result 进行 resolve。</p></li></ol></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/article/promise-chaining/user.json'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 当远程服务器响应时，下面的 .then 开始执行</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当 user.json 加载完成时，response.text() 会返回一个新的 promise</span>    <span class="token comment" spellcheck="true">// 该 promise 以加载的 user.json 为 result 进行 resolve</span>    <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...这是远程文件的内容</span>    <span class="token function">alert</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {"name": "iliakan", "isAdmin": true}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre><code>    &gt;4. 从 `fetch` 返回的 `response` 对象还包括 `response.json()` 方法，该方法读取远程数据并将其解析为 JSON</code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 同上，但是使用 response.json() 将远程内容解析为 JSON</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/article/promise-chaining/user.json'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// iliakan, got user name</span></code></pre><ol start="2"><li>多发一个到 GitHub 的请求，加载用户个人资料并显示头像：</li></ol><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 发送一个对 user.json 的请求</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/article/promise-chaining/user.json'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 将其加载为 JSON</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 发送一个到 GitHub 的请求</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.github.com/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 将响应加载为 JSON</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 显示头像图片（githubUser.avatar_url）3 秒（也可以加上动画效果）</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>githubUser <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> githubUser<span class="token punctuation">.</span>avatar_url<span class="token punctuation">;</span>    img<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"promise-avatar-example"</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> img<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (*)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>链没有扩展性，我们需要返回一个在头像显示结束时进行 resolve 的 promise。</li></ul><pre class=" language-js"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/article/promise-chaining/user.json'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.github.com/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>githubUser <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (*)</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> githubUser<span class="token punctuation">.</span>avatar_url<span class="token punctuation">;</span>    img<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"promise-avatar-example"</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      img<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>githubUser<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (**)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 3 秒后触发</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>githubUser <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Finished showing </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>githubUser<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>第 <code>(*)</code> 行的 <code>.then</code> 处理程序（handler）现在返回一个 <code>new Promise</code>，只有在 <code>setTimeout</code> 中的 <code>resolve(githubUser)</code> <code>(**)</code> 被调用后才会变为 settled。</li><li>异步行为应该始终返回一个 promise。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 整理后的代码</span><span class="token keyword">function</span> <span class="token function">loadJson</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">loadGithubUser</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.github.com/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">showAvatar</span><span class="token punctuation">(</span>githubUser<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img<span class="token punctuation">.</span>src <span class="token operator">=</span> githubUser<span class="token punctuation">.</span>avatar_url<span class="token punctuation">;</span>    img<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"promise-avatar-example"</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      img<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>githubUser<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用它们：</span><span class="token function">loadJson</span><span class="token punctuation">(</span><span class="token string">'/article/promise-chaining/user.json'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token function">loadGithubUser</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>showAvatar<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>githubUser <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Finished showing </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>githubUser<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span></code></pre><p><strong>总结</strong></p><ul><li>如果<code>.then</code> 处理程序返回一个promise，那么链的其他部分都会等待，知道他状态变为settled。</li><li>当他settled，其result（或error），将被进一步传递。</li></ul><img src="/2020/10/13/promise-hui-diao/promise%E9%93%BE%E5%9B%BE.png" class="" title="promise链图"><p><strong>思考</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//这两个代码片段是否相等？换句话说，对于任何处理程序（handler），它们在任何情况下的行为都相同吗？</span><span class="token comment" spellcheck="true">//(1)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(2)</span>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>不相同！！</li><li><code>.then</code> 将 result/error 传递给下一个 <code>.then/.catch</code>。所以在第一个例子中，在下面有一个 <code>catch</code>，而在第二个例子中并没有 <code>catch</code>，所以 error 未被处理。</li></ul><h2 id="使用-promise-进行错误处理"><a href="#使用-promise-进行错误处理" class="headerlink" title="使用 promise 进行错误处理"></a>使用 promise 进行错误处理</h2><ul><li>Promise 链在错误（error）处理中十分强大。当一个 promise 被 reject 时，控制权将移交至最近的 rejection 处理程序（handler）</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 例如：代码中url是错的</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'https://no-such-server.blabla'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// reject</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// TypeError: failed to fetch（这里的文字可能有所不同）</span></code></pre><ul><li><p>尝试可以看到，<code>.catch</code> 不必是立即的。它可能在一个或多个 <code>.then</code> 之后出现。</p></li><li><p>捕获所有 error 的最简单的方法是，将 <code>.catch</code> 附加到链的末尾：（当链中，哪一结promise被reject，就会被捕捉）</p></li></ul><h3 id="隐式-try…catch"><a href="#隐式-try…catch" class="headerlink" title="隐式 try…catch"></a>隐式 try…catch</h3><ul><li>Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 <code>try..catch</code>”</li><li>如果发生异常，异常就会被捕获，并被视为 reject 进行处理。</li></ul><ol><li>下面两段代码工作上相同</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: Whoops!</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: Whoops!</span></code></pre><blockquote><p>在 executor 周围的“隐式 <code>try..catch</code>”自动捕获了 error，并将其变为 rejected promise</p></blockquote><ol start="2"><li>同样在 handler </li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// reject 这个 promise</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: Whoops!</span></code></pre><blockquote><p>我们在 <code>.then</code> 处理程序（handler）中 <code>throw</code>，这意味着 promise 被 rejected，因此控制权移交至最近的 error 处理程序（handler）</p></blockquote><ol start="3"><li>编程错误也是原因</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">blabla</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有这个函数</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ReferenceError: blabla is not defined</span></code></pre><h3 id="再次抛出"><a href="#再次抛出" class="headerlink" title="再次抛出"></a>再次抛出</h3><ul><li>在常规的 <code>try..catch</code> 中，我们可以分析错误（error），如果我们无法处理它，可以将其再次抛出。对于 promise 来说，这也是可以的。</li><li>如果我们在 <code>.catch</code> 中 <code>throw</code>，那么控制权就会被移交到下一个最近的 error 处理程序（handler）。如果我们处理该 error 并正常完成，那么它将继续到最近的成功的 <code>.then</code> 处理程序（handler）。</li></ul><ol><li>执行流：catch -&gt; then</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"The error is handled, continue normally"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Next successful handler runs"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>这里 <code>.catch</code> 块正常完成。所以下一个成功的 <code>.then</code> 处理程序（handler）就会被调用。</p></blockquote><ol start="2"><li>执行流：catch -&gt; catch</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (*)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token keyword">instanceof</span> <span class="token class-name">URIError</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理它</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Can't handle such error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> error<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 不在这里运行 */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (**)</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`The unknown error has occurred: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不会返回任何内容 => 执行正常进行</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>执行从第一个 <code>.catch</code> <code>(*)</code> 沿着链跳转至下一个 <code>(**)</code>。</p></blockquote><h3 id="未处理的-rejection"><a href="#未处理的-rejection" class="headerlink" title="未处理的 rejection"></a>未处理的 rejection</h3><ul><li>当一个 error 没有被处理会发生什么？例如，我们忘了在链的尾端附加 <code>.catch</code></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">noSuchFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里出现 error（没有这个函数）</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 一个或多个成功的 promise 处理程序（handler）</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 尾端没有 .catch！</span></code></pre><blockquote><p>当发生一个常规的错误（error）并且未被 <code>try..catch</code> 捕获时会发生什么？脚本死了，并在控制台（console）中留下了一个信息。对于在 promise 中未被处理的 rejection，也会发生类似的事儿。</p></blockquote><blockquote><p>JavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。如果你运行上面这个代码，你可以在控制台（console）中看到。</p></blockquote><ul><li>在浏览器中，我们可以使用 <code>unhandledrejection</code> 事件来捕获这类 error：</li></ul><pre class=" language-js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'unhandledrejection'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 这个事件对象有两个特殊的属性：</span>  <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [object Promise] - 生成该全局 error 的 promise</span>  <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: Whoops! - 未处理的 error 对象</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Whoops!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有用来处理 error 的 catch</span></code></pre><blockquote><p>如果出现了一个 error，并且在这儿没有 <code>.catch</code>，那么 <code>unhandledrejection</code> 处理程序（handler）就会被触发，并获取具有 error 相关信息的 <code>event</code> 对象，所以我们就能做一些后续处理了</p></blockquote><ul><li>通常此类 error 是无法恢复的，所以我们最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。</li><li>在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。</li></ul><h3 id="Fetch错误实例"><a href="#Fetch错误实例" class="headerlink" title="Fetch错误实例"></a>Fetch错误实例</h3><ul><li>当请求无法发出时，<a href="https://developer.mozilla.org/zh/docs/Web/API/WindowOrWorkerGlobalScope/fetch">fetch</a> reject 会返回 promise</li><li>服务器返回一个错误 500 的非 JSON（non-JSON）页面该怎么办？</li><li>如果没有这个用户，GitHub 返回错误 404 的页面又该怎么办呢？</li></ul><pre class=" language-js"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'no-such-user.json'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// (*)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.github.com/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// (**)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// SyntaxError: Unexpected token &lt; in JSON at position 0</span>  <span class="token comment" spellcheck="true">// ...</span></code></pre><blockquote><ul><li>代码试图以 JSON 格式加载响应数据，但无论如何都会因为语法错误而失败。</li><li>什么失败了，在哪里失败的。</li><li>因此我们多添加一步：我们应该检查具有 HTTP 状态的 <code>response.status</code> 属性，如果不是 200 就抛出错误</li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">HttpError</span> <span class="token keyword">extends</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (1)</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'HttpError'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>response <span class="token operator">=</span> response<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">loadJson</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (2)</span>  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">HttpError</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">loadJson</span><span class="token punctuation">(</span><span class="token string">'no-such-user.json'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// (3)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// HttpError: 404 for .../no-such-user.json</span></code></pre><ol><li>我们为 HTTP 错误创建一个自定义类用于区分 HTTP 错误和其他类型错误。此外，新的类有一个 constructor，它接受 <code>response</code> 对象，并将其保存到 error 中。因此，错误处理（error-handling）代码就能够获得响应数据了。</li><li>然后我们将请求（requesting）和错误处理代码包装进一个函数，它能够 fetch <code>url</code> <strong>并</strong> 将所有状态码不是 200 视为错误。这很方便，因为我们通常需要这样的逻辑。</li><li>现在 <code>alert</code> 显示更多有用的描述信息。</li></ol><ul><li>拥有我们自己的错误处理类的好处是我们可以使用 <code>instanceof</code> 很容易地在错误处理代码中检查错误。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 例子：从 GitHub 加载给定名称的用户。如果没有这个用户，它将告知用户填写正确的名称</span><span class="token keyword">function</span> <span class="token function">demoGithubUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">"Enter a name?"</span><span class="token punctuation">,</span> <span class="token string">"iliakan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">loadJson</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.github.com/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Full name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">HttpError</span> <span class="token operator">&amp;&amp;</span> err<span class="token punctuation">.</span>response<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"No such user, please reenter."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">demoGithubUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> err<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (*)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">demoGithubUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><ul><li>这里的 <code>.catch</code> 会捕获所有错误，但是它仅仅“知道如何处理” <code>HttpError 404</code>。在那种特殊情况下，它意味着没有这样的用户，而 <code>.catch</code> 仅仅在这种情况下重试。</li><li>对于其他错误，仅仅是在 <code>(*)</code> 行再次抛出。</li></ul></blockquote><h3 id="加载指示-finally"><a href="#加载指示-finally" class="headerlink" title="加载指示.finally"></a>加载指示<code>.finally</code></h3><ul><li>如果我们有加载指示（load-indication），<code>.finally</code> 是一个很好的处理程序（handler），在 fetch 完成时停止它：</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">demoGithubUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">"Enter a name?"</span><span class="token punctuation">,</span> <span class="token string">"iliakan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>opacity <span class="token operator">=</span> <span class="token number">0.3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (1) 开始指示（indication）</span>  <span class="token keyword">return</span> <span class="token function">loadJson</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`https://api.github.com/users/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (2) 停止指示（indication）</span>      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>opacity <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (*)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>user <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Full name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>user<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">HttpError</span> <span class="token operator">&amp;&amp;</span> err<span class="token punctuation">.</span>response<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">404</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"No such user, please reenter."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">demoGithubUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> err<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">demoGithubUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><ul><li>此处的 <code>(1)</code> 行，我们通过调暗文档来指示加载</li><li>由于promise没有settled，先进入<code>.then</code> 返回<code>user</code></li><li>最后执行<code>.finally</code> 停止指示</li></ul></blockquote><ul><li>有一个浏览器技巧，<code>(*)</code> 是从 <code>finally</code> 返回零延时（zero-timeout）的 promise。这是因为一些浏览器（比如 Chrome）需要“一点时间”外的 promise 处理程序来绘制文档的更改。因此它确保在进入链下一步之前，指示在视觉上是停止的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数进阶</title>
      <link href="2020/10/13/han-shu-jin-jie/"/>
      <url>2020/10/13/han-shu-jin-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="递归和推栈"><a href="#递归和推栈" class="headerlink" title="递归和推栈"></a>递归和推栈</h1><ul><li><p>首先我们看一下函数底层工作原理：</p><blockquote><p>执行上下文：是一个内部数据结构，包含有关函数执行时的详细细节（控制流所在位置，当前变量，this的值，以及一些内部的细节</p></blockquote><p>当函数嵌套调用时：</p><blockquote><ol><li>当前函数被暂停</li><li>相关的执行上下文被 <code>执行上下文堆栈</code> 的特殊数据结构保存</li><li>执行嵌套调用</li><li>调用结束都，再从堆栈中恢复执行上下文，并从停止的位置恢复外部函数</li></ol></blockquote></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li><p>简要讲一下递归，递归就是上面的函数嵌套调用模式，不断的将当前的上下文压入堆栈的顶端，执行嵌套后的操作；当运行到出口<code>return</code> 时，在从堆栈的顶部一个个的恢复执行的过程</p></li><li><p>所有的递归算法，都可以用循环算法实现，两者的区别</p><blockquote><p>循环算法：一般情况下更加节省内存，更快；但代码结构不如递归直观</p><p>递归算法：算法很直观，易于维护；但占内存大</p></blockquote></li></ul><p>更好的理解递归：我们引入链表</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p>为什么要引入链表？链表这一数据类型在js中不常使用，一般都会使用数数组来，存储数据，但是，当我们使用<code>arr.unshift(obj)</code> 操作必须对所有元素重新编号以便为新的元素 <code>obj</code> 腾出空间，而且如果数组很大，会很耗时。</p><blockquote><p>如果我们确实需要快速插入/删除，则可以选择另一种叫做 [链表]的数据结构</p></blockquote></li><li><p>链表元素：是一个使用递归定义的对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  next<span class="token punctuation">:</span> <span class="token punctuation">{</span>    value<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    next<span class="token punctuation">:</span> <span class="token punctuation">{</span>      value<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      next<span class="token punctuation">:</span> <span class="token punctuation">{</span>        value<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>        next<span class="token punctuation">:</span> <span class="token keyword">null</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><img src="/2020/10/13/han-shu-jin-jie/%E9%93%BE%E8%A1%A8.png" class="" title="链表"><blockquote><p>通过建立了这么一个链式结构：我们对插入删除元素更加的方便</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//比如：头插数据，删除中间节点</span><span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>list <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token string">"new item"</span><span class="token punctuation">,</span> next<span class="token punctuation">:</span> list <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将新值添加到链表头部</span>list<span class="token punctuation">.</span>next <span class="token operator">=</span> list<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//删除value=1的节点</span></code></pre><p>链表的缺点：</p><ul><li>不能和数组一样通过下表快速查找引用</li></ul><p>升级的链表：</p><ul><li>双向链表：添加一个<code>prev</code>属性指向前一个节点，尾部加一个<code>tail</code> 变量指向尾部节点（尾部节点变化时，实时更新）</li></ul></blockquote></li><li><p>实例比较:  </p><ol><li>斐波那契数</li></ol><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//递归算法</span><span class="token keyword">function</span> fib <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">?</span> n<span class="token punctuation">:</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//循环算法（自下而上动态递归）</span><span class="token keyword">function</span> fib <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        a <span class="token operator">=</span> b<span class="token punctuation">;</span>        b <span class="token operator">=</span> c<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//两种算法直观看起来，递归逻辑关系非常的简单，但性能方面有一定的差距</span><span class="token comment" spellcheck="true">//递归算法，算n较大时，非常的慢，而且很占内存！！  比如fib(77);非常慢  </span></code></pre><ol start="2"><li>反向输出链表</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> list <span class="token operator">=</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  next<span class="token punctuation">:</span> <span class="token punctuation">{</span>    value<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    next<span class="token punctuation">:</span> <span class="token punctuation">{</span>      value<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      next<span class="token punctuation">:</span> <span class="token punctuation">{</span>        value<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>        next<span class="token punctuation">:</span> <span class="token keyword">null</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归：使用先遍历，后输出，天然使用上下堆栈的恢复特点</span><span class="token keyword">function</span> <span class="token function">printReverseList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printReverseList</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">alert</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printReverseList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//循环操作：实际上也是新建了一个上下堆栈，存储对应的输出，然后，倒叙循环输出</span><span class="token keyword">function</span> <span class="token function">printReverseList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> tmp <span class="token operator">=</span> list<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">printReverseList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h1 id="Rest参数-Spread语法"><a href="#Rest参数-Spread语法" class="headerlink" title="Rest参数/Spread语法"></a>Rest参数/Spread语法</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_Function </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础知识</title>
      <link href="2020/10/11/javascript-ji-chu-zhi-shi/"/>
      <url>2020/10/11/javascript-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li><h5 id="代码特点"><a href="#代码特点" class="headerlink" title="代码特点"></a>代码特点</h5></li><li><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5></li><li><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5></li><li><h5 id="交互手段（alert，prompt，confirm）"><a href="#交互手段（alert，prompt，confirm）" class="headerlink" title="交互手段（alert，prompt，confirm）"></a>交互手段（alert，prompt，confirm）</h5></li><li><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5></li><li><h5 id="基础数学运算符"><a href="#基础数学运算符" class="headerlink" title="基础数学运算符"></a>基础数学运算符</h5></li><li><h5 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h5></li><li><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5></li><li><h5 id="条件分支（if-和-‘-’"><a href="#条件分支（if-和-‘-’" class="headerlink" title="条件分支（if 和 ‘?’)"></a>条件分支（if 和 ‘?’)</h5></li><li><h5 id="循环（while-和-for）"><a href="#循环（while-和-for）" class="headerlink" title="循环（while 和 for）"></a>循环（while 和 for）</h5></li><li><h5 id="“switch”语句"><a href="#“switch”语句" class="headerlink" title="“switch”语句"></a>“switch”语句</h5></li><li><h5 id="函数，函数表达式"><a href="#函数，函数表达式" class="headerlink" title="函数，函数表达式"></a>函数，函数表达式</h5></li><li><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5></li></ol></blockquote><h1 id="1-代码特点"><a href="#1-代码特点" class="headerlink" title="1.代码特点"></a>1.代码特点</h1><h2 id="“script”标签"><a href="#“script”标签" class="headerlink" title="“script”标签"></a>“script”标签</h2><ul><li><code>&lt;script&gt;</code>标签可以将js程序，插入html文档任何位置</li></ul><h3 id="js程序三种引用方法"><a href="#js程序三种引用方法" class="headerlink" title="js程序三种引用方法"></a>js程序三种引用方法</h3><ol><li><p>行内样式（使用很少）</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"点我试试"</span> onclick<span class="token operator">=</span><span class="token string">"alert('Hello World')"</span><span class="token operator">/</span><span class="token operator">></span></code></pre></li><li><p><code>&lt;script&gt;</code>标签内嵌式</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li><li><p><code>&lt;script&gt;</code>标签引入外部文件</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"my.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ul><li>注意：一个<code>&lt;script&gt;</code>标签只能作为两种方式中的一种使用</li></ul></li></ol><h3 id="现代的标记（makeup）"><a href="#现代的标记（makeup）" class="headerlink" title="现代的标记（makeup）"></a>现代的标记（makeup）</h3><ul><li><p>现在的<code>&lt;script&gt;</code>标签很少再使用特性（attribute），但可以在一些老的代码中找到他们</p><p><code>type</code> 特性 <code>&lt;script type="text/javascript"&gt;</code>,现在用于Javascript模块</p><p><code>language</code> 特性 <code>&lt;script language=...&gt;</code>,现在已经默认js语言，无意义啦</p></li></ul><h2 id="现代模式”use-strict”"><a href="#现代模式”use-strict”" class="headerlink" title="现代模式”use strict”"></a>现代模式”use strict”</h2><ul><li><p>JavaScript 除了提供正常模式(sloppy)外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。</p><blockquote><p>严格模式对正常的 JavaScript 语义做了一些更改： </p><p>1.严格模式通过<strong>抛出错误</strong>来消除了一些原有<strong>静默错误</strong></p><p>2.消除代码运行的一些不安全之处，保证代码运行的安全。</p><p>3.提高编译器效率，<strong>增加运行速度</strong>。</p><p>4.<strong>禁用了</strong>在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p></blockquote></li><li><p>使用方法：推荐加在脚本前</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//更像是一个字符串，放在脚本文件的顶部，整个脚本文件就将以”现代模式“工作</span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token string">"use strict"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//严格模式激活！！一旦激活无法回溯</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li><li><p>严格模式下基本特点</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 对于未声明的变量不允许使用</span><span class="token string">'use strict'</span><span class="token punctuation">;</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//not defined!</span><span class="token comment" spellcheck="true">//严格模式不允许删除变量</span><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">delete</span> num1<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//unqualified！</span><span class="token comment" spellcheck="true">//全局作用域中函数(或构造函数)中的this是 undefined</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    coonsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//严格模式下，定时器 this 还是指向window</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//严格模式下，函数参数不允许有同名的形参</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//4   相当于a=1, a=2 最终a=2</span><span class="token comment" spellcheck="true">//非函数代码块，不允许定义函数,比如if，for中（函数中套函数可以）</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//!!语法错误</span><span class="token punctuation">}</span></code></pre></li><li><p>现代js支持<code>class</code> <code>modules</code>—高级语言结构，会自启动严格模式，无需再加</p></li></ul><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h1><ul><li>我们可以使用<code>var</code> <code>let</code> <code>const</code>来声明变量存储数据</li><li>变量命名：<code>$</code> <code>_</code>字母，数字，  驼峰命名法</li></ul><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul><li>现代变量声明方式</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></code></pre><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ul><li>老旧变量声明方式</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></code></pre><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>常量声明，类似let</li></ul><ol><li><p>大写形式常量：硬编码值的别名</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//比如:web16进制格式的颜色常量声明</span><span class="token keyword">const</span> COLOR_RED <span class="token operator">=</span> <span class="token string">"#F00"</span><span class="token punctuation">;</span><span class="token keyword">const</span> COLOR_BLUE <span class="token operator">=</span> <span class="token string">"#00F"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//...当我们需要一个颜色时</span><span class="token keyword">let</span> color <span class="token operator">=</span> COLOR_BLUE<span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// #00F</span></code></pre></li><li><p>小写形式常量：一般不变的值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> pageDownloadTime <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*网页所需加载时间*/</span>；<span class="token comment" spellcheck="true">//页面加载前是未知的，加载之后就是固定的值</span></code></pre></li></ol><h2 id="var和let区别"><a href="#var和let区别" class="headerlink" title="var和let区别"></a>var和let区别</h2><ol><li><p>var没有块级作用域</p><blockquote><ul><li>即：不是函数作用域就是全局作用域</li></ul></blockquote></li><li><p>var允许重新声明</p><blockquote><ul><li><p>let在同一作用域下，同时声明同一个变量两次会报错</p></li><li><p>var 允许重复声明（第二个声明初始化无效，作用域下确认了前面的声明</p></li></ul></blockquote></li><li><p>var声明的变量，有变量提升</p><blockquote><ul><li>let声明的变量没有变量提升，变量声明必须在变量赋值前</li><li>var声明可以在赋值的后面（声明有提升，赋值没有）</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//看一个有意思的案例</span><span class="token keyword">function</span> sayHi <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    phrase <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//这部分代码理论上是不可能执行的</span>    <span class="token comment" spellcheck="true">//但在进入这个函数作用域时，首先就处理了var语句！！！</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> phrase<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">alert</span><span class="token punctuation">(</span>phrase<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote></li></ol><h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h1><ul><li>js中有8种基本数据类型（7种原始类型，1种引用类型）—动态类型</li></ul><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><ul><li><p>整数和浮点数</p></li><li><p>常规数字和特殊数值（Infinity, -Infinity, 和NaN)</p></li></ul><h2 id="BigInt类型"><a href="#BigInt类型" class="headerlink" title="BigInt类型"></a>BigInt类型</h2><ul><li>number无法表示大于<code>2e53-1</code>或小于<code>-（2e53-1）</code>的整数</li><li>当我们需要加密或者微妙精度的时间戳时，BigInt类型表示任意长度</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//尾部一个n表示是一个BigInt类型</span><span class="token keyword">const</span> bigInt <span class="token operator">=</span> 1234567890123456789012345678901234567890n<span class="token punctuation">;</span></code></pre><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><ul><li><p>字符串必须括在引号里，一共有三种引号</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token string">'single quotes are ok too'</span><span class="token punctuation">;</span><span class="token keyword">let</span> phrase <span class="token operator">=</span> <span class="token template-string"><span class="token string">`can embed another </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>str<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span></code></pre><blockquote><p>功能扩展引号：允许通过将变量和表达式包装在<code>${}</code> 中</p></blockquote></li></ul><h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><ul><li><code>true</code> <code>false</code>两个值</li></ul><h2 id="“null”值"><a href="#“null”值" class="headerlink" title="“null”值"></a>“null”值</h2><ul><li><p>特殊的null不属于上述任何一种类型</p></li><li><p>它构成一个独立的类型。只包含<code>null</code> 值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//表示age是未知的</span><span class="token comment" spellcheck="true">//和其他语言不同，js的null不是一个对不存在的object的引用”或者 “null 指针”</span><span class="token comment" spellcheck="true">//Js中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值。</span></code></pre></li></ul><h2 id="“undefined”值"><a href="#“undefined”值" class="headerlink" title="“undefined”值"></a>“undefined”值</h2><ul><li><p>也是一个独立的类型，表示 <code>未被赋值</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> age<span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//弹出“undefined”</span></code></pre></li></ul><blockquote><p>注：通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值</p></blockquote><h2 id="object类型和symbol类型"><a href="#object类型和symbol类型" class="headerlink" title="object类型和symbol类型"></a>object类型和symbol类型</h2><ul><li><p><code>object</code> 则用于储存数据集合和更复杂的实体</p></li><li><p><code>symbol</code> 类型用于创建对象的唯一标识符</p></li></ul><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><ul><li>支持两种语法形式 (有无括号都一样)<ol><li>作为运算符：<code>typeof x</code></li><li>函数形式：<code>typeof(x)</code></li></ol></li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">typeof</span> undefined         <span class="token comment" spellcheck="true">// "undefined"</span><span class="token keyword">typeof</span> <span class="token number">0</span>                 <span class="token comment" spellcheck="true">// "number"</span><span class="token keyword">typeof</span> 10n                 <span class="token comment" spellcheck="true">// "bigint"</span><span class="token keyword">typeof</span> <span class="token boolean">true</span>             <span class="token comment" spellcheck="true">// "boolean"</span><span class="token keyword">typeof</span> <span class="token string">"foo"</span>             <span class="token comment" spellcheck="true">// "string"</span><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// "symbol"</span><span class="token keyword">typeof</span> Math             <span class="token comment" spellcheck="true">// "object"</span><span class="token keyword">typeof</span> <span class="token keyword">null</span>             <span class="token comment" spellcheck="true">// "object"        语法上的一种错误</span><span class="token keyword">typeof</span> alert            <span class="token comment" spellcheck="true">// "function"    虽然没有function数据类型，但这样很方便！</span></code></pre><h1 id="4-三种交互方式"><a href="#4-三种交互方式" class="headerlink" title="4.三种交互方式"></a>4.三种交互方式</h1><ul><li>这里讲三种模态的，他们中止脚本的执行，不允许用户和其他页面交互，直到窗口被解除</li></ul><h2 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h2><ul><li><p>弹出带信息的<strong>模态框</strong>，（“modal” 意味着用户不能与页面的其他部分）</p><pre class=" language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><ul><li><p>弹出一个带有文本消息的模态窗口，有input框和确定/取消按钮</p><pre class=" language-js"><code class="language-js">result <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span>title<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">default</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//title: 显示文本提示信息</span><span class="token comment" spellcheck="true">//default: 指定input框的默认值        </span></code></pre></li><li><p>访问者输入一些内容，确定就会返回一个字符串类型的值；取消获得null返回值</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">'How old are you?'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`You are </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old!`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// You are 100 years old!</span></code></pre></li><li><p>没有输入内容点击确定，会返回空字符串</p><blockquote><p>IE会提供默认值 undefined </p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//推荐</span><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//加一个空字符串！！</span></code></pre></blockquote></li></ul><h2 id="conform"><a href="#conform" class="headerlink" title="conform"></a>conform</h2><ul><li><p>conform函数，会显示一个带有question以及确认取消按钮的模态框</p></li><li><p>点击确认返回<code>true</code> ，点击取消返回<code>false</code> </p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> isBoss <span class="token operator">=</span> <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">"Are you the boss?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> isBoss <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 如果“确定”按钮被按下，则显示 true</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/10/02/dui-xiang/"/>
      <url>2020/10/02/dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li><p>很多高级语言中都有面向对象的概念，比如<code>js</code>,<code>java</code>等，他们在定义使用方面有什么区别，各有什么特点呢？</p></li><li><p>本人主要学习js，所以先介绍一下，面向对象在JavaScript中是个啥呢？</p></li></ul><h4 id="1-1理解对象"><a href="#1-1理解对象" class="headerlink" title="1.1理解对象"></a>1.1理解对象</h4><ul><li>面向对象（Object-Oriented, OO)的语言有一个标志，那就是他们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象</li><li>首先，在ES6前，js没有类的概念，那时候把对象定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_对象 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="2020/09/26/yuan-xing-lei/"/>
      <url>2020/09/26/yuan-xing-lei/</url>
      
        <content type="html"><![CDATA[<h3 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h3><ul><li>首先说一下什么是原型？</li></ul><blockquote><p>这一概念来自：实例对象中的<code>__proto__</code>属性</p><ul><li>这一属性就是对象的原型（值可以是对象或null）</li><li>指向构造函数的原型对象<code>prototype</code></li><li>并且有且只有一个</li></ul></blockquote><img src="/2020/09/26/yuan-xing-lei/img4.png" class="" title="img4"><ul><li>访问器（accessor）属性是一个例外，因为分配（assignment）操作是由 setter 函数处理的。因此，写入此类属性实际上与调用函数相同。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// admin.fullName 能够正常运行：</span><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"Min"</span><span class="token punctuation">,</span>  surname<span class="token punctuation">:</span> <span class="token string">"Yue"</span><span class="token punctuation">,</span>  <span class="token keyword">set</span> <span class="token function">fullName</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">get</span> <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> admin <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token punctuation">:</span> user<span class="token punctuation">,</span>  isAdmin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>admin<span class="token punctuation">.</span>fullName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Min Yue</span><span class="token comment" spellcheck="true">// setter triggers!</span>admin<span class="token punctuation">.</span>fullName <span class="token operator">=</span> <span class="token string">"He Chengmin"</span><span class="token punctuation">;</span> </code></pre><ul><li>值得思考，这里<code>this</code> 指向问题（当然指向admin）永远是函数名 <code>.</code> 前面的</li></ul><ul><li><code>for...in</code>会迭代继承的属性</li><li><code>Object.keys</code>,<code>Object.values</code> 都会忽略继承属性</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>//两只小鼠共用了一个胃？</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> hamster <span class="token operator">=</span> <span class="token punctuation">{</span>  stomach<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">eat</span><span class="token punctuation">(</span>food<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stomach<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>food<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> speedy <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token punctuation">:</span> hamster<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> lazy <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token punctuation">:</span> hamster<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这只仓鼠找到了食物</span>speedy<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> speedy<span class="token punctuation">.</span>stomach <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// apple</span><span class="token comment" spellcheck="true">// 这只仓鼠也找到了食物，为什么？请修复它。</span><span class="token function">alert</span><span class="token punctuation">(</span> lazy<span class="token punctuation">.</span>stomach <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// apple</span></code></pre><ul><li>解决方案</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// (1):简单的赋值 this.stomach=? 而不是this.stomach.push(food);</span><span class="token comment" spellcheck="true">// this.stomach.push() 需要找到 stomach 属性，然后对其调用 push。它在 this（=speedy）中查找 stomach，但并没有找到。然后它顺着原型链，在 hamster 中找到 stomach。</span><span class="token comment" spellcheck="true">// this.stomach= 不会执行对 stomach 的查找。该值会被直接写入 this 对象。</span><span class="token comment" spellcheck="true">// (2):确保每个小鼠都有自己的胃</span><span class="token keyword">let</span> speedy <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token punctuation">:</span> hamster<span class="token punctuation">,</span>  stomach<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> lazy <span class="token operator">=</span> <span class="token punctuation">{</span>  __proto__<span class="token punctuation">:</span> hamster<span class="token punctuation">,</span>  stomach<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="2-F-prototype"><a href="#2-F-prototype" class="headerlink" title="2.F.prototype"></a>2.F.prototype</h3><ul><li><p>构造函数原型对象</p></li><li><p>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</p><blockquote><p>注意：<code>F.prototype</code> <strong>仅用在</strong> <code>new F</code> <strong>时</strong>调用，它为新对象的 <code>[[Prototype]]</code> 赋值。（原型对象改变（F.prototype = <another object="">）后，不影响前面对象的原型，影响新对象的原型）</another></p></blockquote></li><li><p>当然每个函数都有对应的 <code>"prototype"</code> 属性</p><blockquote><p>默认的 <code>"prototype"</code> 是一个只有属性 <code>constructor</code> 的对象，属性 <code>constructor</code> 指向函数自身。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* default prototypeRabbit.prototype = { constructor: Rabbit };*/</span></code></pre></blockquote><img src="/2020/09/26/yuan-xing-lei/F.prototype.png" class="" title="F.prototype"><blockquote><p>我们也可以使用 <code>constructor</code> 属性来创建一个新对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> rabbit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rabbit</span><span class="token punctuation">(</span><span class="token string">"White Rabbit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> rabbit2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">rabbit<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token string">"Black Rabbit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。</li><li>为了确保正确的 <code>"constructor"</code>，我们可以选择添加/删除属性到默认 <code>"prototype"</code>，而不是将其整个覆盖</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Rabbit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 不要将 Rabbit.prototype 整个覆盖</span><span class="token comment" spellcheck="true">// 可以向其中添加内容</span>Rabbit<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>jumps <span class="token operator">=</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">// 默认的 Rabbit.prototype.constructor 被保留了下来</span>Rabbit<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>  jumps<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  constructor<span class="token punctuation">:</span> Rabbit<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这样的 constructor 也是正确的，因为我们手动添加了它</span></code></pre></blockquote></li></ul><h3 id="3-原生的原型"><a href="#3-原生的原型" class="headerlink" title="3.原生的原型"></a>3.原生的原型</h3><ul><li><p><code>"prototype"</code> 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内置构造函数都用到了它。</p></li><li><p>像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</p><blockquote><p>例如：当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p></blockquote></li></ul><img src="/2020/09/26/yuan-xing-lei/%E5%8E%9F%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9E%8B.png" class="" title="原生的原型"><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li>字符串、数字和布尔值上。</li><li>它们并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 <code>String</code>、<code>Number</code> 和 <code>Boolean</code> 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。</li><li>这些对象的方法也驻留在它们的 prototype 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。</li></ul><p><strong>！！！！</strong>对于<strong>值</strong> <code>null</code> <strong>和</strong> <code>undefined</code> <strong>没有对象包装器</strong></p><h4 id="更改原生原型"><a href="#更改原生原型" class="headerlink" title="更改原生原型"></a>更改原生原型</h4><ul><li><p>原生的原型是可以被修改的。</p><p>例如，我们向 <code>String.prototype</code> 中添加一个方法，这个方法将对所有的字符串都是可用的：</p><pre class=" language-js"><code class="language-js">String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token string">"BOOM!"</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// BOOM!</span></code></pre></li><li><p>通常是一个很不好的想法。</p></li></ul><p><strong>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。</strong></p><ul><li>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>repeat<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果这儿没有这个方法</span>  <span class="token comment" spellcheck="true">// 那就在 prototype 中添加它</span>  String<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>repeat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 重复传入的字符串 n 次</span>    <span class="token comment" spellcheck="true">// 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）</span>    <span class="token comment" spellcheck="true">// 但即使是不够完美的 polyfill 也常常被认为是足够好的</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">alert</span><span class="token punctuation">(</span> <span class="token string">"La"</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// LaLaLa</span></code></pre><h4 id="从原型中借用"><a href="#从原型中借用" class="headerlink" title="从原型中借用"></a>从原型中借用</h4><ul><li>我们从一个对象获取一个方法，并将其复制到另一个对象。一些原生原型的方法通常会被借用。</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//例如：如果我们要创建类数组对象，则可能需要向其中复制一些 Array 方法。</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">"world!"</span><span class="token punctuation">,</span>  length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>join <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Hello,world!</span></code></pre><h3 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4.原型链"></a>4.原型链</h3><ul><li>可以看出对象有原型，构造函数有原型对象！</li><li>对象的原型指向，上级构造函数的原型对象</li><li>向上查找，直到顶级<code>Object.prototype.__proto__</code>指向null</li></ul><img src="/2020/09/26/yuan-xing-lei/img5.png" class="" title="img5"><ul><li>案例分析</li></ul><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">function</span> <span class="token function">Star</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>Star<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>    constructor<span class="token punctuation">:</span> Star<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//手动设置指回原来的构造函数</span>    sing<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"i can sing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    movie<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"i can show"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> xly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Star</span><span class="token punctuation">(</span><span class="token string">"minyue"</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xly<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token string">"women"</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xly<span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xly<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//[Object, Object]</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><img src="/2020/09/26/yuan-xing-lei/%E5%AF%B9%E8%B1%A1.png" class="" title="对象"><ul><li><p>可以看到对象xly的结构如上图所示！</p></li><li><p>toString()是Object.prototype中的函数</p><blockquote><p>而且只有这里的toString()函数可以处理复杂数据类型Object，与普通array的toString()函数功能不同</p><ul><li><p>这里的功能是返回xly元素的数据类型，[Object, Object]表示对象</p><p>[Object, Array]表示数组</p></li></ul></blockquote></li></ul><h4 id="查找机制"><a href="#查找机制" class="headerlink" title="查找机制"></a>查找机制</h4><p>任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链;</p><pre class=" language-html"><code class="language-html">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。如果还没有就查找原型对象的原型（Object的原型对象）。依此类推一直找到 Object 为止（null）。__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js_原型 </tag>
            
            <tag> 原型链 </tag>
            
            <tag> js_类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git_操作</title>
      <link href="2020/07/23/git-cao-zuo/"/>
      <url>2020/07/23/git-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="git和github"><a href="#git和github" class="headerlink" title="git和github"></a>git和github</h1><h2 id="（一）Git基础"><a href="#（一）Git基础" class="headerlink" title="（一）Git基础"></a>（一）Git基础</h2><h3 id="Git基本工作流程"><a href="#Git基本工作流程" class="headerlink" title="Git基本工作流程"></a>Git基本工作流程</h3><blockquote><img src="/2020/07/23/git-cao-zuo/git_%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" class="" title="git操作流程"><p>主要涉及到四个关键点：</p><ol><li>工作区：本地电脑存放项目文件的地方，比如my_work文件夹；</li><li>暂存区（Index/Stage）：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；</li><li>本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；</li><li>远程仓库：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；</li></ol></blockquote><ul><li>关键在于<strong>几个核心存储区的交互命令</strong></li></ul><table><thead><tr><th>工作目录</th><th>暂存区</th><th>git 仓库</th><th>远程仓库</th></tr></thead><tbody><tr><td>被Git管理的项目</td><td>临时存放被修改的文件</td><td>目录用于存放提交记录</td><td>远程代码仓库</td></tr><tr><td><code>git init</code></td><td><code>git add</code></td><td><code>git commit</code></td><td><code>git push</code></td></tr></tbody></table><h3 id="Git使用前的配置命令"><a href="#Git使用前的配置命令" class="headerlink" title="Git使用前的配置命令"></a>Git使用前的配置命令</h3><p>在使用前告诉git你是谁：</p><ol><li><blockquote><p>第一次使用git，配置用户信息</p></blockquote><ol><li>配置用户名：<code>git config --global user.name "your name"</code>;</li><li>配置用户邮箱：<code>git config --global user.email "youremail@github.com"</code>;</li></ol></li><li><blockquote><p>查询配置信息</p></blockquote><ol><li>列出当前配置：<code>git config --list</code>;</li><li>列出repository配置：<code>git config --local --list</code>;</li><li>列出全局配置：<code>git config --global --list</code>;</li><li>列出系统配置：<code>git config --system --list</code>;</li></ol></li></ol><h3 id="工作区上的操作命令"><a href="#工作区上的操作命令" class="headerlink" title="工作区上的操作命令"></a>工作区上的操作命令</h3><h4 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h4><ol><li><p><code>git init</code> 初始化git仓库</p><blockquote><blockquote><p>新建仓库</p></blockquote><ol><li><p>将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：<code>git init</code>；</p><ul><li>会生成一个.git隐藏文件</li></ul></li><li><p>从远程git仓库复制项目：<code>git clone ssh地址 </code> </p><p>eg：<code>git clone git@github.com:xiaoming403/my_work.git</code> </p></li></ol></blockquote></li><li><p><code>git status</code> 查看文件状态</p><blockquote><blockquote><p>查新信息</p></blockquote><ol><li>查询当前工作区所有文件的状态：<code>git status</code>;</li><li>比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较：<code>git diff </code>;</li></ol></blockquote></li><li><p><code>git add 文件/文件列表</code> 提交到暂存区</p><blockquote><blockquote><p>提交</p></blockquote><ol><li>提交工作区所有文件到暂存区：<code>git add .</code></li><li>提交工作区中指定文件到暂存区：<code>git add   ...</code>;</li><li>提交工作区中某个文件夹中所有文件到暂存区：<code>git add [dir]</code>;</li></ol></blockquote></li><li><p><code>git commit -m 提交信息</code> 向仓库提交代码</p><blockquote><blockquote><p>提交文件到版本库</p></blockquote><ol><li>将暂存区中的文件提交到本地仓库中，即打上新版本：<code>git commit -m "commit_info"</code>;</li><li>将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：<code>git commit -a -m "commit_info"</code>;</li><li>提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：<code>git commit --amend</code>;</li></ol></blockquote></li><li><p><code>git log</code> 查看提交记录</p><blockquote><blockquote><p>查看信息</p></blockquote><ol><li>比较暂存区与上一版本的差异：<code>git diff --cached</code>;</li><li>指定文件在暂存区和本地仓库的不同：<code>git diff  --cached</code>;</li><li>查看提交历史：git log；参数<code>-p</code>展开每次提交的内容差异，用<code>-2</code>显示最近的两次更新，如<code>git log -p -2</code>;</li></ol></blockquote></li></ol><ul><li><p><strong>提示：</strong>每天上班第一件事：git pull 拉取线上最新版本；</p><p>​            下班前要做的事：git push 本地代码上传线上仓库</p></li></ul><p><strong>版本回溯</strong></p><ul><li>git reset –hard c72ac3a6e1</li></ul><h2 id="（二）Git分支"><a href="#（二）Git分支" class="headerlink" title="（二）Git分支"></a>（二）Git分支</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>生成副本，避免影响开发主线</p><h4 id="分支细分"><a href="#分支细分" class="headerlink" title="分支细分"></a>分支细分</h4><ol><li>主分支（master）：第一次向git仓库提交更新记录时自动产生的一个分支。</li><li>开发分支（develop）：作为开发的分支，基于master分支创建。</li><li>功能分支（feature）：作为开发具体功能的分支基于开发分支创建。</li></ol><h4 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h4><ul><li><code>git branch</code>    查看分支</li><li><code>git branch 分支名称</code>   创建分支</li><li><code>git checkout 分支名称</code>   切换分支<ul><li>对于新分支，使用<code>git checkout -b 分支名</code>  新建一分支并切换到该分支</li></ul></li><li><code> git merge 被合并的分支名</code>   合并分支</li><li><code>git branch -d 分支名称</code> 删除分支（分支合并后（退出该分支）才允许被删除）（-D 大写强制删除）<ul><li><code>git push origin :branch-name</code> : 远程仓库同步删除掉的分支</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> gitbub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字体图标使用</title>
      <link href="2020/07/20/zi-ti-tu-biao-shi-yong/"/>
      <url>2020/07/20/zi-ti-tu-biao-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><h4 id="1，为什么要使用字体图标？"><a href="#1，为什么要使用字体图标？" class="headerlink" title="1，为什么要使用字体图标？"></a>1，为什么要使用字体图标？</h4><ul><li>字体图标是文本属性，可以更改文本样式达到更改效果</li><li>字体图标兼容性好，与传统图片图标相比更加轻量级</li><li>多用在小图标中！！</li></ul><h4 id="2，如何使用字体图标呢？"><a href="#2，如何使用字体图标呢？" class="headerlink" title="2，如何使用字体图标呢？"></a>2，如何使用字体图标呢？</h4><ul><li>首先我们需要下载字体图标</li></ul><ol><li>在icomeen，是一个外网可能会有点慢！    <a href="http://icomoon.io/">http://icomoon.io</a></li><li>在阿里的iconfont <a href="http://www.iconfont.cn/">http://www.iconfont.cn/</a> </li></ol><ul><li>这里我们以阿里为例：</li></ul><ol><li><p>选好你喜欢的图标，下载文字代码</p></li><li><p>可以看到压缩包里面有一个demo文件（使用说明书）</p><img src="/2020/07/20/zi-ti-tu-biao-shi-yong/pic.png" class="" title="show1"></li><li><p>一般都可以使用Font class方法，调用.css文件就行（但这里需要标签调用）</p></li></ol><h4 id="3，特殊使用-伪元素选择器中"><a href="#3，特殊使用-伪元素选择器中" class="headerlink" title="3，特殊使用-伪元素选择器中"></a>3，特殊使用-伪元素选择器中</h4><ul><li>由于这里不能新建标签，所以我们使用UNICODE(16进制字符实体/转义字符)</li></ul><p>第一步：拷贝项目下面生成的@font-face(到style中）</p><pre class=" language-html"><code class="language-html">@font-face {  font-family: 'iconfont';  src: url('iconfont.eot');  src: url('iconfont.eot?#iefix') format('embedded-opentype'),      url('iconfont.woff2') format('woff2'),      url('iconfont.woff') format('woff'),      url('iconfont.ttf') format('truetype'),      url('iconfont.svg#iconfont') format('svg');}</code></pre><p>第二步：将定义使用iconfont样式中的设定拷贝到伪元素中</p><pre class=" language-html"><code class="language-html">div::after {            font-family: "iconfont" !important;            font-size: 16px;            font-style: normal;            -webkit-font-smoothing: antialiased;            -moz-osx-font-smoothing: grayscale;            content: "\e64f";        }</code></pre><ul><li>这里css的content接受16进制的 Unicode编码，但<strong>不能</strong>写作实体字符**&amp;#xe64f**；（实体字符只用在html页面中！！： &amp;# 是开头用以标明这是字符实体，x表示这是十六进制）</li></ul><img src="/2020/07/20/zi-ti-tu-biao-shi-yong/show.png" class="" title="show2">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字体图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github常用操作</title>
      <link href="2020/07/04/hexo-github-chang-yong-cao-zuo/"/>
      <url>2020/07/04/hexo-github-chang-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="如何部署到网站"><a href="#如何部署到网站" class="headerlink" title="如何部署到网站"></a>如何部署到网站</h1><h2 id="三步走："><a href="#三步走：" class="headerlink" title="三步走："></a>三步走：</h2><h3 id="1-1-hexo-clean"><a href="#1-1-hexo-clean" class="headerlink" title="1,1 hexo clean"></a>1,1 hexo clean</h3><p>清理缓存文件(db.json)和已生成的静态文件(public)</p><pre class=" language-bash"><code class="language-bash">$ hexo clean</code></pre><p>[^特别是当换主题时！！！]:</p><h3 id="1-2-hexo-generate（hexo-g）"><a href="#1-2-hexo-generate（hexo-g）" class="headerlink" title="1,2 hexo generate（hexo g）"></a>1,2 hexo generate（hexo g）</h3><p>生成静态文件</p><pre class=" language-bash"><code class="language-bash">$ hexo g</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d</td><td>文件生成后立即部署网站</td></tr><tr><td>-w</td><td>监事文件变动</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="1-3-hexo-deploy-hexo-d"><a href="#1-3-hexo-deploy-hexo-d" class="headerlink" title="1,3 hexo deploy (hexo d)"></a>1,3 hexo deploy (hexo d)</h3><p>部署网站</p><pre class=" language-bash"><code class="language-bash">$ hexo d</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g</td><td>部署之前，先生成静态文件</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="1-4gulp压缩代码"><a href="#1-4gulp压缩代码" class="headerlink" title="1.4gulp压缩代码"></a>1.4gulp压缩代码</h3><pre class=" language-bash"><code class="language-bash">$ gulp build        //相当于hexo cl<span class="token operator">&amp;&amp;</span>hexo g<span class="token operator">&amp;&amp;</span>hexo d</code></pre><p>hexo</p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>其中也可以加入 hexo server （hexo s）启动本地服务器访问<a href="http://localhost:4000/.%E6%9D%A5%E6%B5%8B%E8%AF%95%E9%9D%99%E6%80%81%E7%95%8C%E9%9D%A2%E6%98%AF%E5%90%A6%E7%AC%A6%E5%90%88%E9%A2%84%E6%9C%9F">http://localhost:4000/.来测试静态界面是否符合预期</a></p><pre><code> &lt;http://xiaoming403.github.io&gt;</code></pre><h1 id="文章书写规范"><a href="#文章书写规范" class="headerlink" title="文章书写规范"></a>文章书写规范</h1><h3 id="1，文章front-matter"><a href="#1，文章front-matter" class="headerlink" title="1，文章front-matter"></a>1，文章front-matter</h3><ul><li>建议至少填写title和date值</li></ul><pre><code>---title: typora-vue-theme主题介绍date: 2020-07-07 09:25:00author: xiaoming403img: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>Markdown 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 _config.yml 中的 author</td><td>文章作者</td></tr><tr><td>img</td><td>featureImages 中的某个值</td><td>文章特征图，推荐使用图床 (腾讯云、七牛云、又拍云等) 来做图片的路径。如: <a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></td></tr><tr><td>top</td><td>true</td><td>推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td>cover</td><td>false</td><td>v1.0.2 版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项</td></tr><tr><td>mathjax</td><td>false</td><td>是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><ul><li>注：如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。</li></ul><p>[^以上front-matter内容：学习参考 <a href="https://yafine-blog.cn/posts/4ab2.html">https://yafine-blog.cn/posts/4ab2.html</a>]: </p><h3 id="2-图片添加方式"><a href="#2-图片添加方式" class="headerlink" title="2,图片添加方式"></a>2,图片添加方式</h3><ul><li>需要在目录新建一个与.md相同名称的文件夹存放img</li><li>调用格式如下：</li></ul><pre><code>{% asset_img 图片名称和后缀 图片脚注 %}</code></pre><ul><li>范例：<img src="/2020/07/04/hexo-github-chang-yong-cao-zuo/pic%E7%A4%BA%E4%BE%8B.png" class="" title="pic示例"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网站部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo指令 </tag>
            
            <tag> .md书写规范 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
